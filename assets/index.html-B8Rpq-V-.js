import{_ as l,c as t,a as n,e as s,b as i,w as p,r as d,o,d as r}from"./app-DoYSvn9w.js";const c={};function m(h,e){const a=d("VPLink");return o(),t("div",null,[e[2]||(e[2]=n("blockquote",null,[n("ul",null,[n("li",null,"Fast, disk space efficient package manager"),n("li",null,"快，节省磁盘空间，的 package 管理器")])],-1)),e[3]||(e[3]=n("p",null,"相关链接",-1)),n("ul",null,[n("li",null,[i(a,{href:"!https://www.pnpm.cn/"},{default:p(()=>e[0]||(e[0]=[r("pnpm 中文网",-1)])),_:1,__:[0]})])]),e[4]||(e[4]=s(`<h2 id="高效利用磁盘空间" tabindex="-1"><a class="header-anchor" href="#高效利用磁盘空间"><span>高效利用磁盘空间</span></a></h2><p>硬链接(Hard Link)</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>硬连接指通过索引节点来进行连接。</span></span>
<span class="line"><span>在Linux的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。</span></span>
<span class="line"><span>在Linux中，多个文件名指向同一索引节点是存在的。一般这种连接就是硬连接。</span></span>
<span class="line"><span>硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。</span></span>
<span class="line"><span>只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。</span></span>
<span class="line"><span>也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>软连接(Symbolic Link)</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>另外一种连接称之为符号连接，也叫软连接。</span></span>
<span class="line"><span>软链接文件有类似于Windows的快捷方式。</span></span>
<span class="line"><span>它实际上是一个特殊的文件。</span></span>
<span class="line"><span>在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="支持-monorepo" tabindex="-1"><a class="header-anchor" href="#支持-monorepo"><span>支持 monorepo</span></a></h2><p>monorepo 的宗旨就是用一个 git 仓库来管理多个子项目，所有的子项目都存放在根目录的 packages 目录下，那么一个子项目就代表一个 package。</p><p>monorepo 管理工具 <code>lerna</code></p><p>项目参考：<code>babel</code></p><h2 id="安全" tabindex="-1"><a class="header-anchor" href="#安全"><span>安全</span></a></h2><p>之前在使用 npm/yarn 的时候，由于 node_module 的扁平结构，如果 A 依赖 B， B 依赖 C，那么 A 当中是可以直接使用 C 的，但问题是 A 当中并没有声明 C 这个依赖。</p><p>因此会出现这种非法访问的情况。</p><p>但 pnpm 自创了一套依赖管理方式，很好地解决了这个问题，保证了安全性。</p>`,13)),n("blockquote",null,[n("p",null,[i(a,{href:"!./nodeModules.md"},{default:p(()=>e[1]||(e[1]=[r("node_modules 结构历史",-1)])),_:1,__:[1]})])]),e[5]||(e[5]=s('<h2 id="不适用的场景" tabindex="-1"><a class="header-anchor" href="#不适用的场景"><span>不适用的场景</span></a></h2><p>前面有提到关于 pnpm 的主要问题在于 symlink(软链接)在一些场景下会存在兼容的问题，可以参考作者在 nodejs 那边开的一个 <a href="https://github.com/nodejs/node/discussions/37509" target="_blank" rel="noopener noreferrer">node discussion</a></p><p>在里面作者提到了目前 nodejs 软连接不能适用的一些场景，希望 nodejs 能提供一种 link 方式而不是使用软连接，同时也提到了 pnpm 目前因为软连接而不能使用的场景:</p><ul><li>Electron 应用无法使用 pnpm</li><li>部署在 lambda 上的应用无法使用 pnpm</li><li>一些 nodejs 基础库不支持 symlink 的情况导致使用 pnpm 无法正常工作，不过这些库在迭代更新之后也会支持这一特性。</li></ul><h2 id="未来会做的一些事情" tabindex="-1"><a class="header-anchor" href="#未来会做的一些事情"><span>未来会做的一些事情</span></a></h2><h3 id="脱离-node-js" tabindex="-1"><a class="header-anchor" href="#脱离-node-js"><span>脱离 Node.js</span></a></h3><p>具体可以参考 <a href="https://github.com/pnpm/pnpm/discussions/3434" target="_blank" rel="noopener noreferrer">pnpm discussions</a></p><p>安装 pnpm 的， 可以基本上脱离掉 nodejs 这个 runtime 去进行安装使用。</p><p>可以通过 pnpm 来使用不同版本的 nodejs 来去做依赖安装，类似于 nvm 提供的功能。</p><p>目前该特性其实已经到了 <a href="https://www.npmjs.com/package/@pnpm/beta" target="_blank" rel="noopener noreferrer">beta 版本</a>，可以参考这个包。</p><p>管理不同版本的 nodejs 功能可以参考 env 这个子命令: <a href="https://pnpm.io/cli/env" target="_blank" rel="noopener noreferrer">pnpm-cli-env</a></p><h3 id="使用-rust-写一些模块" tabindex="-1"><a class="header-anchor" href="#使用-rust-写一些模块"><span>使用 rust 写一些模块</span></a></h3><p>具体可以看<a href="https://github.com/pnpm/pnpm/discussions/3419" target="_blank" rel="noopener noreferrer">pnpm discussion</a>讨论的内容，大概就是作者希望给 pnpm 的一些子命令提供一些 rust 的 cli wrapper 来做提升性能使用。</p>',13))])}const g=l(c,[["render",m]]),b=JSON.parse('{"path":"/nodejs/package/4t9ndsf8/","title":"pnpm","lang":"zh-CN","frontmatter":{"title":"pnpm","createTime":"2025/08/14 23:23:11","permalink":"/nodejs/package/4t9ndsf8/","tag":["Node.js","pnpm"]},"readingTime":{"minutes":3.07,"words":921},"git":{"createdTime":1657197837000,"updatedTime":1755609321000,"contributors":[{"name":"wangzhijie","username":"wangzhijie","email":"1662285571@qq.com","commits":4,"avatar":"https://avatars.githubusercontent.com/wangzhijie?v=4","url":"https://github.com/wangzhijie"},{"name":"王志杰","username":"","email":"wangzhijie@wangzhijiedeMacBook-Air.local","commits":2,"avatar":"https://gravatar.com/avatar/20fcaa5bda6c4e5c80745c9999b7c3cb416609636f8769c329005d42fb7cb6c8?d=retro"},{"name":"wangzhije","username":"wangzhije","email":"1662285571@qq.com","commits":2,"avatar":"https://avatars.githubusercontent.com/wangzhije?v=4","url":"https://github.com/wangzhije"}]},"filePathRelative":"notes/2.nodejs/2.包管理/4.pnpm.md","headers":[]}');export{g as comp,b as data};
