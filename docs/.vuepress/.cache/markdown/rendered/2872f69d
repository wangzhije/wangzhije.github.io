{"content":"<h2 id=\"什么是模式\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#什么是模式\"><span>什么是模式？</span></a></h2>\n<p>模式是一种解决方案，可用于解决软件设计中遇到的常见问题。</p>\n<div class=\"hint-container important\">\n<p class=\"hint-container-title\">我们每天都在使用 <mark class=\"caution\">模式</mark> ！</p>\n</div>\n<h2 id=\"为什么学习模式\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#为什么学习模式\"><span>为什么学习模式？</span></a></h2>\n<p>模式主要有三大优点：</p>\n<ul>\n<li>\n<p><strong>模式是已验证的解决方案</strong></p>\n<p>它们为解决软件开发中遇到的问题提供可靠的方法。\n使用已验证的解决方案，这些解决方案体现了开发人员的经验及见解。</p>\n</li>\n<li>\n<p><strong>模式很容易被复用</strong></p>\n<p>模式通常是一种立即可用的解决方案，可以对其进行修改以满足个人需求。\n该特性是的这些模式的功能非常强大。</p>\n</li>\n<li>\n<p><strong>模式富有表达力</strong></p>\n<p>看到模式时，通常就表示有一个设置好的结构和表达解决方案的词汇，已帮助我们非常轻松的表达出所实现的解决方案。</p>\n</li>\n</ul>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">小提示</p>\n<p>模式的作用仅仅是为我们提供一个解决问题的方案。\n模式无法解决所有的问题，也无法取代优秀软件设计师的工作，但模式能够为这些工作提供支持。</p>\n</div>\n<p>设计模式的其它优点：</p>\n<ul>\n<li>复用模式有助于防止在应用程序开发过程中小问题引发大问题。</li>\n<li>模式可以提供通用的解决方案，并且其记录方式不需要与某个特定问题挂钩。</li>\n<li>某些模式确实能够通过避免代码复用来减少代码的总体资源占用量。</li>\n<li>模式添加到开发人员的词汇中，会使沟通更快速。</li>\n</ul>\n<h2 id=\"编写设计模式\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#编写设计模式\"><span>编写设计模式</span></a></h2>\n<p>编写优秀的设计模式是一项具有挑战性的任务。\n模式不仅需要为最终用户提供大量的参考资源，还需要能够证明自己为何是必要的。</p>\n<ul>\n<li>\n<p><strong>模式的实用性有多少？</strong></p>\n<p>确保模式描述的事能够解决重复出现的问题的已经验证的解决方案。</p>\n</li>\n<li>\n<p><strong>牢记最佳实践</strong></p>\n<p>做出的设计决策应该基于通过对最佳实践的理解而获得的原则。</p>\n</li>\n<li>\n<p><strong>设计模式对于用户来说应该是透明的</strong></p>\n<p>设计模式对于任何类型的用户体验都应是完全透明的。\n它们主要是为使用它们的开发人员提供服务，而不应强制改变用户的行为。</p>\n</li>\n<li>\n<p><strong>要记住独创性在模式设计中不是重点</strong></p>\n<p>编写模式时，我们不需要是已有解决方案的最初发现者，也不必担心我们的设计有一小部分与其他模式有重叠，\n如果我们的方法很强大，有广泛的适用性，那么它就有可能被认定为是一个有效的模式。</p>\n</li>\n<li>\n<p><strong>模式需要一批有说服力的示例</strong></p>\n<p>好的模式描述需要伴随着一系列同样强有力的示例，以演示所编写模式的成功应用。</p>\n</li>\n</ul>\n<h2 id=\"反模式\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#反模式\"><span>反模式</span></a></h2>\n<p>如果我们认为一种模式代表一种最佳实践，那么一种反模式就代表我们已经学到的教训。</p>\n<p>反模式是：</p>\n<ul>\n<li>描述一种针对某个特定问题的不良解决方案，该方案会导致糟糕的情况发生；</li>\n<li>描述如何摆脱前述的糟糕情况以及如何创造好的解决方案。</li>\n</ul>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">反模式是一种值得记录的不良设计。</p>\n</div>\n<h2 id=\"设计模式类别\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#设计模式类别\"><span>设计模式类别</span></a></h2>\n<h3 id=\"创建型设计模式\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#创建型设计模式\"><span>创建型设计模式</span></a></h3>\n<p>创建型设计模式专注于处理对象创建机制，以适合给定情况的方式来创建对象。</p>\n<p>创建对象的基本方法可能导致项目复杂性增加，而这些模式旨在通过控制创建过程来解决这种问题。</p>\n<p>创建型设计模式包括：</p>\n<ul>\n<li><strong>Constructor</strong> - 构造器</li>\n<li><strong>Factory</strong> - 工厂</li>\n<li><strong>Abstract</strong> - 抽象</li>\n<li><strong>Prototype</strong> - 原型</li>\n<li><strong>Singleton</strong> - 单例</li>\n<li><strong>Builder</strong> - 生成器</li>\n</ul>\n<h3 id=\"结构型设计模式\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#结构型设计模式\"><span>结构型设计模式</span></a></h3>\n<p>结构型模式与对象组合有关，通常可以用于找出在不同对象之间建立关系的简单方法。</p>\n<p>这种模式有助于确保在系统某一部分发生变化时，系统的整个结构不需要同时改变。\n同时对于不适合因某个特定目的而改变的系统部分，这种模式也能够帮助它们完成重组。</p>\n<p>结构型设计模式包括：</p>\n<ul>\n<li><strong>Decorator</strong> - 装饰器</li>\n<li><strong>Facade</strong> - 外观</li>\n<li><strong>Flyweight</strong> - 享元</li>\n<li><strong>Adapter</strong> - 适配器</li>\n<li><strong>Proxy</strong> - 代理</li>\n</ul>\n<h3 id=\"行为型设计模式\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#行为型设计模式\"><span>行为型设计模式</span></a></h3>\n<p>行为模式专注于改善或简化系统中不同对象之间的通信。</p>\n<p>行为模式包括：</p>\n<ul>\n<li><strong>Iterator</strong> - 迭代器</li>\n<li><strong>Mediator</strong> - 中介者</li>\n<li><strong>Observer</strong> - 观察者</li>\n<li><strong>Visitor</strong> - 访问者</li>\n</ul>\n","env":{"base":"/blog/","filePath":"/Users/wangzhijie/Desktop/myspace/wangzhije.github.io/docs/notes/topic/设计模式/start.md","filePathRelative":"notes/topic/设计模式/start.md","frontmatter":{"title":"start","createTime":"2025/08/22 16:06:12","permalink":"/design/spetio1d/"},"sfcBlocks":{"template":{"type":"template","content":"<template><h2 id=\"什么是模式\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#什么是模式\"><span>什么是模式？</span></a></h2>\n<p>模式是一种解决方案，可用于解决软件设计中遇到的常见问题。</p>\n<div class=\"hint-container important\">\n<p class=\"hint-container-title\">我们每天都在使用 <mark class=\"caution\">模式</mark> ！</p>\n</div>\n<h2 id=\"为什么学习模式\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#为什么学习模式\"><span>为什么学习模式？</span></a></h2>\n<p>模式主要有三大优点：</p>\n<ul>\n<li>\n<p><strong>模式是已验证的解决方案</strong></p>\n<p>它们为解决软件开发中遇到的问题提供可靠的方法。\n使用已验证的解决方案，这些解决方案体现了开发人员的经验及见解。</p>\n</li>\n<li>\n<p><strong>模式很容易被复用</strong></p>\n<p>模式通常是一种立即可用的解决方案，可以对其进行修改以满足个人需求。\n该特性是的这些模式的功能非常强大。</p>\n</li>\n<li>\n<p><strong>模式富有表达力</strong></p>\n<p>看到模式时，通常就表示有一个设置好的结构和表达解决方案的词汇，已帮助我们非常轻松的表达出所实现的解决方案。</p>\n</li>\n</ul>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">小提示</p>\n<p>模式的作用仅仅是为我们提供一个解决问题的方案。\n模式无法解决所有的问题，也无法取代优秀软件设计师的工作，但模式能够为这些工作提供支持。</p>\n</div>\n<p>设计模式的其它优点：</p>\n<ul>\n<li>复用模式有助于防止在应用程序开发过程中小问题引发大问题。</li>\n<li>模式可以提供通用的解决方案，并且其记录方式不需要与某个特定问题挂钩。</li>\n<li>某些模式确实能够通过避免代码复用来减少代码的总体资源占用量。</li>\n<li>模式添加到开发人员的词汇中，会使沟通更快速。</li>\n</ul>\n<h2 id=\"编写设计模式\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#编写设计模式\"><span>编写设计模式</span></a></h2>\n<p>编写优秀的设计模式是一项具有挑战性的任务。\n模式不仅需要为最终用户提供大量的参考资源，还需要能够证明自己为何是必要的。</p>\n<ul>\n<li>\n<p><strong>模式的实用性有多少？</strong></p>\n<p>确保模式描述的事能够解决重复出现的问题的已经验证的解决方案。</p>\n</li>\n<li>\n<p><strong>牢记最佳实践</strong></p>\n<p>做出的设计决策应该基于通过对最佳实践的理解而获得的原则。</p>\n</li>\n<li>\n<p><strong>设计模式对于用户来说应该是透明的</strong></p>\n<p>设计模式对于任何类型的用户体验都应是完全透明的。\n它们主要是为使用它们的开发人员提供服务，而不应强制改变用户的行为。</p>\n</li>\n<li>\n<p><strong>要记住独创性在模式设计中不是重点</strong></p>\n<p>编写模式时，我们不需要是已有解决方案的最初发现者，也不必担心我们的设计有一小部分与其他模式有重叠，\n如果我们的方法很强大，有广泛的适用性，那么它就有可能被认定为是一个有效的模式。</p>\n</li>\n<li>\n<p><strong>模式需要一批有说服力的示例</strong></p>\n<p>好的模式描述需要伴随着一系列同样强有力的示例，以演示所编写模式的成功应用。</p>\n</li>\n</ul>\n<h2 id=\"反模式\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#反模式\"><span>反模式</span></a></h2>\n<p>如果我们认为一种模式代表一种最佳实践，那么一种反模式就代表我们已经学到的教训。</p>\n<p>反模式是：</p>\n<ul>\n<li>描述一种针对某个特定问题的不良解决方案，该方案会导致糟糕的情况发生；</li>\n<li>描述如何摆脱前述的糟糕情况以及如何创造好的解决方案。</li>\n</ul>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">反模式是一种值得记录的不良设计。</p>\n</div>\n<h2 id=\"设计模式类别\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#设计模式类别\"><span>设计模式类别</span></a></h2>\n<h3 id=\"创建型设计模式\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#创建型设计模式\"><span>创建型设计模式</span></a></h3>\n<p>创建型设计模式专注于处理对象创建机制，以适合给定情况的方式来创建对象。</p>\n<p>创建对象的基本方法可能导致项目复杂性增加，而这些模式旨在通过控制创建过程来解决这种问题。</p>\n<p>创建型设计模式包括：</p>\n<ul>\n<li><strong>Constructor</strong> - 构造器</li>\n<li><strong>Factory</strong> - 工厂</li>\n<li><strong>Abstract</strong> - 抽象</li>\n<li><strong>Prototype</strong> - 原型</li>\n<li><strong>Singleton</strong> - 单例</li>\n<li><strong>Builder</strong> - 生成器</li>\n</ul>\n<h3 id=\"结构型设计模式\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#结构型设计模式\"><span>结构型设计模式</span></a></h3>\n<p>结构型模式与对象组合有关，通常可以用于找出在不同对象之间建立关系的简单方法。</p>\n<p>这种模式有助于确保在系统某一部分发生变化时，系统的整个结构不需要同时改变。\n同时对于不适合因某个特定目的而改变的系统部分，这种模式也能够帮助它们完成重组。</p>\n<p>结构型设计模式包括：</p>\n<ul>\n<li><strong>Decorator</strong> - 装饰器</li>\n<li><strong>Facade</strong> - 外观</li>\n<li><strong>Flyweight</strong> - 享元</li>\n<li><strong>Adapter</strong> - 适配器</li>\n<li><strong>Proxy</strong> - 代理</li>\n</ul>\n<h3 id=\"行为型设计模式\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#行为型设计模式\"><span>行为型设计模式</span></a></h3>\n<p>行为模式专注于改善或简化系统中不同对象之间的通信。</p>\n<p>行为模式包括：</p>\n<ul>\n<li><strong>Iterator</strong> - 迭代器</li>\n<li><strong>Mediator</strong> - 中介者</li>\n<li><strong>Observer</strong> - 观察者</li>\n<li><strong>Visitor</strong> - 访问者</li>\n</ul>\n</template>","contentStripped":"<h2 id=\"什么是模式\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#什么是模式\"><span>什么是模式？</span></a></h2>\n<p>模式是一种解决方案，可用于解决软件设计中遇到的常见问题。</p>\n<div class=\"hint-container important\">\n<p class=\"hint-container-title\">我们每天都在使用 <mark class=\"caution\">模式</mark> ！</p>\n</div>\n<h2 id=\"为什么学习模式\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#为什么学习模式\"><span>为什么学习模式？</span></a></h2>\n<p>模式主要有三大优点：</p>\n<ul>\n<li>\n<p><strong>模式是已验证的解决方案</strong></p>\n<p>它们为解决软件开发中遇到的问题提供可靠的方法。\n使用已验证的解决方案，这些解决方案体现了开发人员的经验及见解。</p>\n</li>\n<li>\n<p><strong>模式很容易被复用</strong></p>\n<p>模式通常是一种立即可用的解决方案，可以对其进行修改以满足个人需求。\n该特性是的这些模式的功能非常强大。</p>\n</li>\n<li>\n<p><strong>模式富有表达力</strong></p>\n<p>看到模式时，通常就表示有一个设置好的结构和表达解决方案的词汇，已帮助我们非常轻松的表达出所实现的解决方案。</p>\n</li>\n</ul>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">小提示</p>\n<p>模式的作用仅仅是为我们提供一个解决问题的方案。\n模式无法解决所有的问题，也无法取代优秀软件设计师的工作，但模式能够为这些工作提供支持。</p>\n</div>\n<p>设计模式的其它优点：</p>\n<ul>\n<li>复用模式有助于防止在应用程序开发过程中小问题引发大问题。</li>\n<li>模式可以提供通用的解决方案，并且其记录方式不需要与某个特定问题挂钩。</li>\n<li>某些模式确实能够通过避免代码复用来减少代码的总体资源占用量。</li>\n<li>模式添加到开发人员的词汇中，会使沟通更快速。</li>\n</ul>\n<h2 id=\"编写设计模式\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#编写设计模式\"><span>编写设计模式</span></a></h2>\n<p>编写优秀的设计模式是一项具有挑战性的任务。\n模式不仅需要为最终用户提供大量的参考资源，还需要能够证明自己为何是必要的。</p>\n<ul>\n<li>\n<p><strong>模式的实用性有多少？</strong></p>\n<p>确保模式描述的事能够解决重复出现的问题的已经验证的解决方案。</p>\n</li>\n<li>\n<p><strong>牢记最佳实践</strong></p>\n<p>做出的设计决策应该基于通过对最佳实践的理解而获得的原则。</p>\n</li>\n<li>\n<p><strong>设计模式对于用户来说应该是透明的</strong></p>\n<p>设计模式对于任何类型的用户体验都应是完全透明的。\n它们主要是为使用它们的开发人员提供服务，而不应强制改变用户的行为。</p>\n</li>\n<li>\n<p><strong>要记住独创性在模式设计中不是重点</strong></p>\n<p>编写模式时，我们不需要是已有解决方案的最初发现者，也不必担心我们的设计有一小部分与其他模式有重叠，\n如果我们的方法很强大，有广泛的适用性，那么它就有可能被认定为是一个有效的模式。</p>\n</li>\n<li>\n<p><strong>模式需要一批有说服力的示例</strong></p>\n<p>好的模式描述需要伴随着一系列同样强有力的示例，以演示所编写模式的成功应用。</p>\n</li>\n</ul>\n<h2 id=\"反模式\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#反模式\"><span>反模式</span></a></h2>\n<p>如果我们认为一种模式代表一种最佳实践，那么一种反模式就代表我们已经学到的教训。</p>\n<p>反模式是：</p>\n<ul>\n<li>描述一种针对某个特定问题的不良解决方案，该方案会导致糟糕的情况发生；</li>\n<li>描述如何摆脱前述的糟糕情况以及如何创造好的解决方案。</li>\n</ul>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">反模式是一种值得记录的不良设计。</p>\n</div>\n<h2 id=\"设计模式类别\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#设计模式类别\"><span>设计模式类别</span></a></h2>\n<h3 id=\"创建型设计模式\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#创建型设计模式\"><span>创建型设计模式</span></a></h3>\n<p>创建型设计模式专注于处理对象创建机制，以适合给定情况的方式来创建对象。</p>\n<p>创建对象的基本方法可能导致项目复杂性增加，而这些模式旨在通过控制创建过程来解决这种问题。</p>\n<p>创建型设计模式包括：</p>\n<ul>\n<li><strong>Constructor</strong> - 构造器</li>\n<li><strong>Factory</strong> - 工厂</li>\n<li><strong>Abstract</strong> - 抽象</li>\n<li><strong>Prototype</strong> - 原型</li>\n<li><strong>Singleton</strong> - 单例</li>\n<li><strong>Builder</strong> - 生成器</li>\n</ul>\n<h3 id=\"结构型设计模式\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#结构型设计模式\"><span>结构型设计模式</span></a></h3>\n<p>结构型模式与对象组合有关，通常可以用于找出在不同对象之间建立关系的简单方法。</p>\n<p>这种模式有助于确保在系统某一部分发生变化时，系统的整个结构不需要同时改变。\n同时对于不适合因某个特定目的而改变的系统部分，这种模式也能够帮助它们完成重组。</p>\n<p>结构型设计模式包括：</p>\n<ul>\n<li><strong>Decorator</strong> - 装饰器</li>\n<li><strong>Facade</strong> - 外观</li>\n<li><strong>Flyweight</strong> - 享元</li>\n<li><strong>Adapter</strong> - 适配器</li>\n<li><strong>Proxy</strong> - 代理</li>\n</ul>\n<h3 id=\"行为型设计模式\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#行为型设计模式\"><span>行为型设计模式</span></a></h3>\n<p>行为模式专注于改善或简化系统中不同对象之间的通信。</p>\n<p>行为模式包括：</p>\n<ul>\n<li><strong>Iterator</strong> - 迭代器</li>\n<li><strong>Mediator</strong> - 中介者</li>\n<li><strong>Observer</strong> - 观察者</li>\n<li><strong>Visitor</strong> - 访问者</li>\n</ul>\n","tagOpen":"<template>","tagClose":"</template>"},"script":null,"scriptSetup":null,"scripts":[],"styles":[],"customBlocks":[]},"content":"## 什么是模式？\n\n模式是一种解决方案，可用于解决软件设计中遇到的常见问题。\n\n::: important 我们每天都在使用 ==模式=={.caution} ！\n:::\n\n## 为什么学习模式？\n\n模式主要有三大优点：\n\n- **模式是已验证的解决方案**\n\n  它们为解决软件开发中遇到的问题提供可靠的方法。\n  使用已验证的解决方案，这些解决方案体现了开发人员的经验及见解。\n\n- **模式很容易被复用**\n\n  模式通常是一种立即可用的解决方案，可以对其进行修改以满足个人需求。\n  该特性是的这些模式的功能非常强大。\n\n- **模式富有表达力**\n\n  看到模式时，通常就表示有一个设置好的结构和表达解决方案的词汇，已帮助我们非常轻松的表达出所实现的解决方案。\n\n::: tip 小提示\n\n模式的作用仅仅是为我们提供一个解决问题的方案。\n模式无法解决所有的问题，也无法取代优秀软件设计师的工作，但模式能够为这些工作提供支持。\n\n:::\n\n设计模式的其它优点：\n\n- 复用模式有助于防止在应用程序开发过程中小问题引发大问题。\n- 模式可以提供通用的解决方案，并且其记录方式不需要与某个特定问题挂钩。\n- 某些模式确实能够通过避免代码复用来减少代码的总体资源占用量。\n- 模式添加到开发人员的词汇中，会使沟通更快速。\n\n## 编写设计模式\n\n编写优秀的设计模式是一项具有挑战性的任务。\n模式不仅需要为最终用户提供大量的参考资源，还需要能够证明自己为何是必要的。\n\n- **模式的实用性有多少？**\n\n  确保模式描述的事能够解决重复出现的问题的已经验证的解决方案。\n\n- **牢记最佳实践**\n\n  做出的设计决策应该基于通过对最佳实践的理解而获得的原则。\n\n- **设计模式对于用户来说应该是透明的**\n\n  设计模式对于任何类型的用户体验都应是完全透明的。\n  它们主要是为使用它们的开发人员提供服务，而不应强制改变用户的行为。\n\n- **要记住独创性在模式设计中不是重点**\n\n  编写模式时，我们不需要是已有解决方案的最初发现者，也不必担心我们的设计有一小部分与其他模式有重叠，\n  如果我们的方法很强大，有广泛的适用性，那么它就有可能被认定为是一个有效的模式。\n\n- **模式需要一批有说服力的示例**\n\n  好的模式描述需要伴随着一系列同样强有力的示例，以演示所编写模式的成功应用。\n\n## 反模式\n\n如果我们认为一种模式代表一种最佳实践，那么一种反模式就代表我们已经学到的教训。\n\n反模式是：\n\n- 描述一种针对某个特定问题的不良解决方案，该方案会导致糟糕的情况发生；\n- 描述如何摆脱前述的糟糕情况以及如何创造好的解决方案。\n\n::: tip 反模式是一种值得记录的不良设计。\n:::\n\n## 设计模式类别\n\n### 创建型设计模式\n\n创建型设计模式专注于处理对象创建机制，以适合给定情况的方式来创建对象。\n\n创建对象的基本方法可能导致项目复杂性增加，而这些模式旨在通过控制创建过程来解决这种问题。\n\n创建型设计模式包括：\n\n- **Constructor** - 构造器\n- **Factory** - 工厂\n- **Abstract** - 抽象\n- **Prototype** - 原型\n- **Singleton** - 单例\n- **Builder** - 生成器\n\n### 结构型设计模式\n\n结构型模式与对象组合有关，通常可以用于找出在不同对象之间建立关系的简单方法。\n\n这种模式有助于确保在系统某一部分发生变化时，系统的整个结构不需要同时改变。\n同时对于不适合因某个特定目的而改变的系统部分，这种模式也能够帮助它们完成重组。\n\n结构型设计模式包括：\n\n- **Decorator** - 装饰器\n- **Facade** - 外观\n- **Flyweight** - 享元\n- **Adapter** - 适配器\n- **Proxy** - 代理\n\n### 行为型设计模式\n\n行为模式专注于改善或简化系统中不同对象之间的通信。\n\n行为模式包括：\n\n- **Iterator** - 迭代器\n- **Mediator** - 中介者\n- **Observer** - 观察者\n- **Visitor** - 访问者","excerpt":"","includedFiles":[],"tasklistId":0,"title":"","headers":[{"level":2,"title":"什么是模式？","slug":"什么是模式","link":"#什么是模式","children":[]},{"level":2,"title":"为什么学习模式？","slug":"为什么学习模式","link":"#为什么学习模式","children":[]},{"level":2,"title":"编写设计模式","slug":"编写设计模式","link":"#编写设计模式","children":[]},{"level":2,"title":"反模式","slug":"反模式","link":"#反模式","children":[]},{"level":2,"title":"设计模式类别","slug":"设计模式类别","link":"#设计模式类别","children":[{"level":3,"title":"创建型设计模式","slug":"创建型设计模式","link":"#创建型设计模式","children":[]},{"level":3,"title":"结构型设计模式","slug":"结构型设计模式","link":"#结构型设计模式","children":[]},{"level":3,"title":"行为型设计模式","slug":"行为型设计模式","link":"#行为型设计模式","children":[]}]}]}}
