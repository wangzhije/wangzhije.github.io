{"content":"<p>整个过程的步骤：</p>\n<ol>\n<li>查看 DNS 缓存；命中缓存，则直接返回；没有缓存，往下进行</li>\n</ol>\n<ul>\n<li>浏览器缓存</li>\n<li>操作系统缓存</li>\n<li>路由器缓存</li>\n<li>ISP 缓存</li>\n</ul>\n<ol start=\"2\">\n<li>DNS 解析：将解析域名获取 IP 地址</li>\n<li>浏览器缓存：命中缓存，则直接返回，否则进行网络请求并渲染页面</li>\n<li>TCP 连接：通过 IP 向服务器发起 TCP 连接，TCP 三次握手</li>\n<li>向目标服务器发送 HTTP 请求报文，分析 url，设置请求报文头，报文主体</li>\n<li>服务器处理请求，并返回 HTTP 报文</li>\n<li>浏览器开始解析渲染页面并显示</li>\n<li>断开 TCP 连接：TCP 四次挥手</li>\n</ol>\n<h2 id=\"dns\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#dns\"><span>DNS</span></a></h2>\n<blockquote>\n<p>域名系统（英文：Domain Name System，缩写：DNS）是互联网的一项服务。</p>\n<p>它作为将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。</p>\n<p>DNS 使用 TCP 和 UDP 端口 53。</p>\n<p>当前，对于每一级域名长度的限制是 63 个字符，域名总长度则不能超过 253 个字符。</p>\n<p>--维基百科</p>\n</blockquote>\n<h3 id=\"域名解析的过程是逐级查询的\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#域名解析的过程是逐级查询的\"><span><font style=\"color:rgb(33, 37, 41);\">域名解析的过程是逐级查询的</font></span></a></h3>\n<h4 id=\"浏览器缓存\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#浏览器缓存\"><span><font style=\"color:rgb(33, 37, 41);\">浏览器缓存</font></span></a></h4>\n<font style=\"color:rgb(33, 37, 41);\">首先会向浏览器的缓存中读取上一次访问的记录，</font><font style=\"color:rgb(33, 37, 41);\">在 chrome 可以通过地址栏中输入 chrome://net-internals/#dns 查看 DNS 缓存的当前状态</font><h4 id=\"操作系统缓存\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#操作系统缓存\"><span><font style=\"color:rgb(33, 37, 41);\">操作系统缓存</font></span></a></h4>\n<font style=\"color:rgb(33, 37, 41);\">查找存储在系统运行内存中的缓存。</font><font style=\"color:rgb(33, 37, 41);\">过程：</font><ol>\n<li>\n<font style=\"color:rgb(33, 37, 41);\">在 host 文件中查找：如果在缓存中都查找不到的情况下，就会读取系统中预设的 host 文件中的设置。</font></li>\n<li>\n<font style=\"color:rgb(33, 37, 41);\">路由器缓存：有些路由器也有 DNS 缓存的功能，访问过的域名会存在路由器上。</font></li>\n<li>\n<font style=\"color:rgb(33, 37, 41);\">ISP DNS 缓存：互联网服务提供商（如中国电信）也会提供 DNS 服务，比如比较著名的 114.114.114.114，在本地查找不到的情况下，就会向 ISP 进行查询，ISP 会在当前服务器的缓存内查找是否有记录，如果有，则返回这个 IP，若没有，则会开始向根域名服务器请求查询。</font></li>\n<li>\n<font style=\"color:rgb(33, 37, 41);\">顶级 DNS 服务器/根 DNS 服务器：根域名收到请求后，会判别这个域名(.com)是授权给哪台服务器管理,并返回这个顶级 DNS 服务器的 IP。请求者收到这台顶级 DNS 的服务器 IP 后，会向该服务器发起查询，如果该服务器无法解析，该服务器就会返回下一级的 DNS 服务器 IP（nicefilm.com），本机继续查找，直到服务器找到(www.nicefilm.com)的主机。</font></li>\n</ol>\n<font style=\"color:rgb(33, 37, 41);\">MacOS</font><ul>\n<li><code v-pre>dscacheutil -flushcache</code><font style=\"color:rgb(33, 37, 41);\">清除系统中的 DNS 缓存</font></li>\n<li><code v-pre>dig 域名地址</code>查看域名解析的记录</li>\n</ul>\n<h2 id=\"tcp-连接-三次握手\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#tcp-连接-三次握手\"><span>TCP 连接，三次握手</span></a></h2>\n<p>拿到了要请求的资源服务器 IP 后，浏览器通过操作 OS 的 socket 与服务器进行 TCP 连接。</p>\n<h3 id=\"tcp-三次握手\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#tcp-三次握手\"><span>TCP 三次握手</span></a></h3>\n<p>本机主动打开连接：</p>\n<ul>\n<li>第一次，本机将标识位 SYN 置为 1, seq = x(Sequence number)发送给服务端。此时本机状态为 SYN-SENT</li>\n<li>第二次，服务器收到包之后，将状态切换为 SYN-RECEIVED，并将标识位 SYN 和 ACK 都置为 1, seq = y, ack = x + 1, 并发送给客户端。</li>\n<li>第三次，客户端收到包后，将状态切换为 ESTABLISHED，并将标识位 ACK 置为 1，seq = x + 1, ack = y + 1, 并发送给服务端。服务端收到包之后，也将状态切换为 ESTABLISHED。</li>\n</ul>\n<h3 id=\"理解\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#理解\"><span>理解</span></a></h3>\n<ul>\n<li>标识位 ACK 置为 1 表示我已确认收到 seq 为 x 的包，并回复确认序号 ack = x + 1</li>\n<li>SYN 表示这是我第一次随机生成 seq 的序列 x，此后我每次发送的包都会在上一次发送的基础上增加 y（有数据的时候，y 是数据的长度，没有的时候 y = 1）。所以，当 seq 已初始化完成之后，没必要再把 SYN 置为 1</li>\n</ul>\n<p>理解了这两点，也就不难理解为什么三次握手分别是 SYN、ACK/SYN、ACK 了。</p>\n<p><strong>标识位（TCP FLAG）</strong></p>\n<p>TCP 的头部固定有 20 个字节，其中分配了 6bits 给 TCP FLAG，组合起来用来表示当前包的类型。</p>\n<p>分别是 URG ACK PSH RST SYN FIN</p>\n<ul>\n<li>URG：紧急指针，用于将要发送的包标识为“紧急”，这意味着不必等待前段数据被响应处理完即可发送给接收端。</li>\n<li>ACK：确认标识，用于表示对数据包的成功接收。</li>\n<li>PSH：推送标识，表示这个数据包应该被立即发送，不需要等待额外的数据。</li>\n<li>RST：reset 标识，用来异常关闭连接。</li>\n<li>SYN：同步标识，表示 TCP 连接已初始化。</li>\n<li>FIN：完成标识，用于拆除上一个 SYN 标识。一个完整的 TCP 连接过程一定会有 SYN 和 FIN 包。</li>\n</ul>\n<p>至此我们了解了一个 TCP 连接的过程，通道通了，是时候利用这个通道送东西了。</p>\n<p>我们从传输层再回到应用层。</p>\n<h2 id=\"http-请求与响应\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#http-请求与响应\"><span>HTTP 请求与响应</span></a></h2>\n<blockquote>\n<p>超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。</p>\n<p>HTTP 是万维网的数据通信的基础。</p>\n<p>设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。</p>\n<p>通过 HTTP 或者 HTTPS 协议请求的资源由统一资源标识符（Uniform Resource Identifiers，URI）来标识。</p>\n<font style=\"color:rgb(33, 37, 41);\">--维基百科</font></blockquote>\n<h3 id=\"http-请求\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#http-请求\"><span>http 请求</span></a></h3>\n<p>在应用层，浏览器会分析这个 url，并设置好请求报文发出。</p>\n<p>https 默认请求端口 443， http 默认 80。</p>\n<p>请求报文中包括请求行、请求头、空行、请求主体。</p>\n<ul>\n<li>请求行：请求行中包括请求的方法，路径和协议版本。</li>\n<li>请求头：请求头中包含了请求的一些附加的信息，一般是以键值的形式成对存在，比如设置请求文件的类型 accept-type，以及服务器对缓存的设置。</li>\n<li>空行：协议中规定请求头和请求主体间必须用一个空行隔开</li>\n<li>请求主体：对于 post 请求，所需要的参数都不会放在 url 中，这时候就需要一个载体了，这个载体就是请求主题。</li>\n</ul>\n<h3 id=\"http-响应\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#http-响应\"><span>http 响应</span></a></h3>\n<p>服务端收到请求之后，会根据 url 匹配到的路径做相应的处理，最后返回浏览器需要的页面资源。</p>\n<p>浏览器会收到一个响应报文，而所需要的资源就就在报文主体上。</p>\n<p>与请求报文相同，响应报文也有与之对应的起始行、首部、空行、报文主体，不同的地方在于包含的东西不一样。</p>\n<ul>\n<li>响应行：响应报文的起始行同样包含了协议版本，与请求的起始行不同的是其包含的还有状态码和状态码的原因短语。</li>\n<li>响应头：对应请求报文中的请求头，格式一致，但是各自有不同的首部。也有一起用的通用首部。</li>\n<li>空行</li>\n<li>报文主体：请求所需要的资源。</li>\n</ul>\n<h2 id=\"浏览器渲染\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#浏览器渲染\"><span>浏览器渲染</span></a></h2>\n<font style=\"color:rgb(33, 37, 41);\">浏览器拿到了一个 HTML 文档，并为了呈现文档而开始解析。</font><font style=\"color:rgb(33, 37, 41);\">呈现引擎开始工作，基本流程如下:</font><ul>\n<li>\n<font style=\"color:rgb(33, 37, 41);\">通过 HTML 解析器解析 HTML 文档，</font><ul>\n<li>\n<font style=\"color:rgb(33, 37, 41);\">构建一个 DOM Tree</font></li>\n<li>\n<font style=\"color:rgb(33, 37, 41);\">同时通过 CSS 解析器解析 HTML 中存在的 CSS，构建 Style Rules</font></li>\n<li>\n<font style=\"color:rgb(33, 37, 41);\">两者结合形成一个 Attachment</font></li>\n</ul>\n</li>\n<li>\n<font style=\"color:rgb(33, 37, 41);\">通过 Attachment 构造出一个呈现树（Render Tree）</font></li>\n<li>\n<font style=\"color:rgb(33, 37, 41);\">Render Tree 构建完毕，进入到布局阶段（layout/reflow），将会为每个阶段分配一个应出现在屏幕上的确切坐标。</font></li>\n<li>\n<font style=\"color:rgb(33, 37, 41);\">最后将全部的节点遍历绘制出来后，一个页面就展现出来了。</font></li>\n</ul>\n<font style=\"color:rgb(33, 37, 41);\"></font><font style=\"color:rgb(33, 37, 41);\">从构建 DOM 树到呈现的过程如下</font><div class=\"language-bash line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"bash\" style=\"--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212\"><pre class=\"shiki shiki-themes vitesse-light vitesse-dark vp-code\" v-pre=\"\"><code class=\"language-bash\"><span class=\"line\"><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">op</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">=</span><span style=\"--shiki-light:#AB5959;--shiki-dark:#CB7676\">></span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\">operation:</span><span style=\"--shiki-light:#59873A;--shiki-dark:#80A665\"> Parsing</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\"> HTML</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\"> to</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\"> construct</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\"> the</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\"> DOM</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\"> tree</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">op1</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">=</span><span style=\"--shiki-light:#AB5959;--shiki-dark:#CB7676\">></span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\">operation:</span><span style=\"--shiki-light:#59873A;--shiki-dark:#80A665\"> Render</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\"> Tree</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\"> construction</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">op2</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">=</span><span style=\"--shiki-light:#AB5959;--shiki-dark:#CB7676\">></span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\">operation:</span><span style=\"--shiki-light:#59873A;--shiki-dark:#80A665\"> Layout</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\"> of</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\"> the</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\"> Render</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\"> Tree</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">op3</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">=</span><span style=\"--shiki-light:#AB5959;--shiki-dark:#CB7676\">></span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\">operation:</span><span style=\"--shiki-light:#59873A;--shiki-dark:#80A665\"> Painting</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\"> the</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\"> Render</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\"> Tree</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#59873A;--shiki-dark:#80A665\">op-</span><span style=\"--shiki-light:#393A34;--shiki-dark:#DBD7CAEE\">></span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\">op1-</span><span style=\"--shiki-light:#393A34;--shiki-dark:#DBD7CAEE\">></span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\">op2-</span><span style=\"--shiki-light:#393A34;--shiki-dark:#DBD7CAEE\">></span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\">op3</span></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2 id=\"tcp-断开连接-四次挥手\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#tcp-断开连接-四次挥手\"><span>TCP 断开连接，四次挥手</span></a></h2>\n<p>现在的页面为了优化请求的耗时，默认都会开启持久连接（keep-alive），那么一个 TCP 连接确切关闭的时机，是这个 tab 标签页关闭的时候。</p>\n<p>这个关闭的过程就是著名的四次挥手。</p>\n<h3 id=\"tcp-四次挥手\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#tcp-四次挥手\"><span>TCP 四次挥手</span></a></h3>\n<p>关闭是一个全双工的过程，发包的顺序的不一定的。</p>\n<p>一般来说是客户端主动发起的关闭，过程如下。</p>\n<p>假如最后一次客户端发出的数据 seq = x, ack = y;</p>\n<ul>\n<li>客户端发送一个 FIN 置为 1 的包，ack = y， seq = x + 1，此时客户端的状态为 FIN_WAIT_1</li>\n<li>服务端收到包后，状态切换为 CLOSE_WAIT 发送一个 ACK 为 1 的包， ack = x + 2。客户端收到包之后状态切换为 FNI_WAIT_2</li>\n<li>服务端处理完任务后，向客户端发送一个 FIN 包，seq = y; 同时将自己的状态置为 LAST_ACK</li>\n<li>客户端收到包后状态切换为 TIME_WAIT，并向服务端发送 ACK 包，ack = y + 1，等待 2MSL 后关闭连接。</li>\n</ul>\n<h3 id=\"为什么客户端等待-2msl\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#为什么客户端等待-2msl\"><span>为什么客户端等待 2MSL？</span></a></h3>\n<p>MSL: 全程 Maximum Segment Lifetime，中文可以翻译为报文最大生存时间。</p>\n<p>等待是为了保证连接的可靠性，确保服务端收到 ACK 包，如果服务端没有收到这个 ACK 包，将会重发 FIN 包给客户端，而这个时间刚好是服务端等待超时重发的时间 + FIN 的传输时间。</p>\n","env":{"base":"/blog/","filePath":"/Users/wangzhijie/Desktop/myspace/wangzhije.github.io/docs/notes/6.计算机网络/从URL到网页.md","filePathRelative":"notes/6.计算机网络/从URL到网页.md","frontmatter":{"title":"从URL到网页","createTime":"2025/08/18 00:13:12","permalink":"/network/b5tbbr5b/","tags":["计算机网络","浏览器"]},"sfcBlocks":{"template":{"type":"template","content":"<template><p>整个过程的步骤：</p>\n<ol>\n<li>查看 DNS 缓存；命中缓存，则直接返回；没有缓存，往下进行</li>\n</ol>\n<ul>\n<li>浏览器缓存</li>\n<li>操作系统缓存</li>\n<li>路由器缓存</li>\n<li>ISP 缓存</li>\n</ul>\n<ol start=\"2\">\n<li>DNS 解析：将解析域名获取 IP 地址</li>\n<li>浏览器缓存：命中缓存，则直接返回，否则进行网络请求并渲染页面</li>\n<li>TCP 连接：通过 IP 向服务器发起 TCP 连接，TCP 三次握手</li>\n<li>向目标服务器发送 HTTP 请求报文，分析 url，设置请求报文头，报文主体</li>\n<li>服务器处理请求，并返回 HTTP 报文</li>\n<li>浏览器开始解析渲染页面并显示</li>\n<li>断开 TCP 连接：TCP 四次挥手</li>\n</ol>\n<h2 id=\"dns\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#dns\"><span>DNS</span></a></h2>\n<blockquote>\n<p>域名系统（英文：Domain Name System，缩写：DNS）是互联网的一项服务。</p>\n<p>它作为将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。</p>\n<p>DNS 使用 TCP 和 UDP 端口 53。</p>\n<p>当前，对于每一级域名长度的限制是 63 个字符，域名总长度则不能超过 253 个字符。</p>\n<p>--维基百科</p>\n</blockquote>\n<h3 id=\"域名解析的过程是逐级查询的\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#域名解析的过程是逐级查询的\"><span><font style=\"color:rgb(33, 37, 41);\">域名解析的过程是逐级查询的</font></span></a></h3>\n<h4 id=\"浏览器缓存\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#浏览器缓存\"><span><font style=\"color:rgb(33, 37, 41);\">浏览器缓存</font></span></a></h4>\n<font style=\"color:rgb(33, 37, 41);\">首先会向浏览器的缓存中读取上一次访问的记录，</font><font style=\"color:rgb(33, 37, 41);\">在 chrome 可以通过地址栏中输入 chrome://net-internals/#dns 查看 DNS 缓存的当前状态</font><h4 id=\"操作系统缓存\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#操作系统缓存\"><span><font style=\"color:rgb(33, 37, 41);\">操作系统缓存</font></span></a></h4>\n<font style=\"color:rgb(33, 37, 41);\">查找存储在系统运行内存中的缓存。</font><font style=\"color:rgb(33, 37, 41);\">过程：</font><ol>\n<li>\n<font style=\"color:rgb(33, 37, 41);\">在 host 文件中查找：如果在缓存中都查找不到的情况下，就会读取系统中预设的 host 文件中的设置。</font></li>\n<li>\n<font style=\"color:rgb(33, 37, 41);\">路由器缓存：有些路由器也有 DNS 缓存的功能，访问过的域名会存在路由器上。</font></li>\n<li>\n<font style=\"color:rgb(33, 37, 41);\">ISP DNS 缓存：互联网服务提供商（如中国电信）也会提供 DNS 服务，比如比较著名的 114.114.114.114，在本地查找不到的情况下，就会向 ISP 进行查询，ISP 会在当前服务器的缓存内查找是否有记录，如果有，则返回这个 IP，若没有，则会开始向根域名服务器请求查询。</font></li>\n<li>\n<font style=\"color:rgb(33, 37, 41);\">顶级 DNS 服务器/根 DNS 服务器：根域名收到请求后，会判别这个域名(.com)是授权给哪台服务器管理,并返回这个顶级 DNS 服务器的 IP。请求者收到这台顶级 DNS 的服务器 IP 后，会向该服务器发起查询，如果该服务器无法解析，该服务器就会返回下一级的 DNS 服务器 IP（nicefilm.com），本机继续查找，直到服务器找到(www.nicefilm.com)的主机。</font></li>\n</ol>\n<font style=\"color:rgb(33, 37, 41);\">MacOS</font><ul>\n<li><code v-pre>dscacheutil -flushcache</code><font style=\"color:rgb(33, 37, 41);\">清除系统中的 DNS 缓存</font></li>\n<li><code v-pre>dig 域名地址</code>查看域名解析的记录</li>\n</ul>\n<h2 id=\"tcp-连接-三次握手\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#tcp-连接-三次握手\"><span>TCP 连接，三次握手</span></a></h2>\n<p>拿到了要请求的资源服务器 IP 后，浏览器通过操作 OS 的 socket 与服务器进行 TCP 连接。</p>\n<h3 id=\"tcp-三次握手\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#tcp-三次握手\"><span>TCP 三次握手</span></a></h3>\n<p>本机主动打开连接：</p>\n<ul>\n<li>第一次，本机将标识位 SYN 置为 1, seq = x(Sequence number)发送给服务端。此时本机状态为 SYN-SENT</li>\n<li>第二次，服务器收到包之后，将状态切换为 SYN-RECEIVED，并将标识位 SYN 和 ACK 都置为 1, seq = y, ack = x + 1, 并发送给客户端。</li>\n<li>第三次，客户端收到包后，将状态切换为 ESTABLISHED，并将标识位 ACK 置为 1，seq = x + 1, ack = y + 1, 并发送给服务端。服务端收到包之后，也将状态切换为 ESTABLISHED。</li>\n</ul>\n<h3 id=\"理解\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#理解\"><span>理解</span></a></h3>\n<ul>\n<li>标识位 ACK 置为 1 表示我已确认收到 seq 为 x 的包，并回复确认序号 ack = x + 1</li>\n<li>SYN 表示这是我第一次随机生成 seq 的序列 x，此后我每次发送的包都会在上一次发送的基础上增加 y（有数据的时候，y 是数据的长度，没有的时候 y = 1）。所以，当 seq 已初始化完成之后，没必要再把 SYN 置为 1</li>\n</ul>\n<p>理解了这两点，也就不难理解为什么三次握手分别是 SYN、ACK/SYN、ACK 了。</p>\n<p><strong>标识位（TCP FLAG）</strong></p>\n<p>TCP 的头部固定有 20 个字节，其中分配了 6bits 给 TCP FLAG，组合起来用来表示当前包的类型。</p>\n<p>分别是 URG ACK PSH RST SYN FIN</p>\n<ul>\n<li>URG：紧急指针，用于将要发送的包标识为“紧急”，这意味着不必等待前段数据被响应处理完即可发送给接收端。</li>\n<li>ACK：确认标识，用于表示对数据包的成功接收。</li>\n<li>PSH：推送标识，表示这个数据包应该被立即发送，不需要等待额外的数据。</li>\n<li>RST：reset 标识，用来异常关闭连接。</li>\n<li>SYN：同步标识，表示 TCP 连接已初始化。</li>\n<li>FIN：完成标识，用于拆除上一个 SYN 标识。一个完整的 TCP 连接过程一定会有 SYN 和 FIN 包。</li>\n</ul>\n<p>至此我们了解了一个 TCP 连接的过程，通道通了，是时候利用这个通道送东西了。</p>\n<p>我们从传输层再回到应用层。</p>\n<h2 id=\"http-请求与响应\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#http-请求与响应\"><span>HTTP 请求与响应</span></a></h2>\n<blockquote>\n<p>超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。</p>\n<p>HTTP 是万维网的数据通信的基础。</p>\n<p>设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。</p>\n<p>通过 HTTP 或者 HTTPS 协议请求的资源由统一资源标识符（Uniform Resource Identifiers，URI）来标识。</p>\n<font style=\"color:rgb(33, 37, 41);\">--维基百科</font></blockquote>\n<h3 id=\"http-请求\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#http-请求\"><span>http 请求</span></a></h3>\n<p>在应用层，浏览器会分析这个 url，并设置好请求报文发出。</p>\n<p>https 默认请求端口 443， http 默认 80。</p>\n<p>请求报文中包括请求行、请求头、空行、请求主体。</p>\n<ul>\n<li>请求行：请求行中包括请求的方法，路径和协议版本。</li>\n<li>请求头：请求头中包含了请求的一些附加的信息，一般是以键值的形式成对存在，比如设置请求文件的类型 accept-type，以及服务器对缓存的设置。</li>\n<li>空行：协议中规定请求头和请求主体间必须用一个空行隔开</li>\n<li>请求主体：对于 post 请求，所需要的参数都不会放在 url 中，这时候就需要一个载体了，这个载体就是请求主题。</li>\n</ul>\n<h3 id=\"http-响应\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#http-响应\"><span>http 响应</span></a></h3>\n<p>服务端收到请求之后，会根据 url 匹配到的路径做相应的处理，最后返回浏览器需要的页面资源。</p>\n<p>浏览器会收到一个响应报文，而所需要的资源就就在报文主体上。</p>\n<p>与请求报文相同，响应报文也有与之对应的起始行、首部、空行、报文主体，不同的地方在于包含的东西不一样。</p>\n<ul>\n<li>响应行：响应报文的起始行同样包含了协议版本，与请求的起始行不同的是其包含的还有状态码和状态码的原因短语。</li>\n<li>响应头：对应请求报文中的请求头，格式一致，但是各自有不同的首部。也有一起用的通用首部。</li>\n<li>空行</li>\n<li>报文主体：请求所需要的资源。</li>\n</ul>\n<h2 id=\"浏览器渲染\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#浏览器渲染\"><span>浏览器渲染</span></a></h2>\n<font style=\"color:rgb(33, 37, 41);\">浏览器拿到了一个 HTML 文档，并为了呈现文档而开始解析。</font><font style=\"color:rgb(33, 37, 41);\">呈现引擎开始工作，基本流程如下:</font><ul>\n<li>\n<font style=\"color:rgb(33, 37, 41);\">通过 HTML 解析器解析 HTML 文档，</font><ul>\n<li>\n<font style=\"color:rgb(33, 37, 41);\">构建一个 DOM Tree</font></li>\n<li>\n<font style=\"color:rgb(33, 37, 41);\">同时通过 CSS 解析器解析 HTML 中存在的 CSS，构建 Style Rules</font></li>\n<li>\n<font style=\"color:rgb(33, 37, 41);\">两者结合形成一个 Attachment</font></li>\n</ul>\n</li>\n<li>\n<font style=\"color:rgb(33, 37, 41);\">通过 Attachment 构造出一个呈现树（Render Tree）</font></li>\n<li>\n<font style=\"color:rgb(33, 37, 41);\">Render Tree 构建完毕，进入到布局阶段（layout/reflow），将会为每个阶段分配一个应出现在屏幕上的确切坐标。</font></li>\n<li>\n<font style=\"color:rgb(33, 37, 41);\">最后将全部的节点遍历绘制出来后，一个页面就展现出来了。</font></li>\n</ul>\n<font style=\"color:rgb(33, 37, 41);\"></font><font style=\"color:rgb(33, 37, 41);\">从构建 DOM 树到呈现的过程如下</font><div class=\"language-bash line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"bash\" style=\"--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212\"><pre class=\"shiki shiki-themes vitesse-light vitesse-dark vp-code\" v-pre=\"\"><code class=\"language-bash\"><span class=\"line\"><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">op</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">=</span><span style=\"--shiki-light:#AB5959;--shiki-dark:#CB7676\">></span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\">operation:</span><span style=\"--shiki-light:#59873A;--shiki-dark:#80A665\"> Parsing</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\"> HTML</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\"> to</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\"> construct</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\"> the</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\"> DOM</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\"> tree</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">op1</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">=</span><span style=\"--shiki-light:#AB5959;--shiki-dark:#CB7676\">></span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\">operation:</span><span style=\"--shiki-light:#59873A;--shiki-dark:#80A665\"> Render</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\"> Tree</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\"> construction</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">op2</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">=</span><span style=\"--shiki-light:#AB5959;--shiki-dark:#CB7676\">></span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\">operation:</span><span style=\"--shiki-light:#59873A;--shiki-dark:#80A665\"> Layout</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\"> of</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\"> the</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\"> Render</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\"> Tree</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">op3</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">=</span><span style=\"--shiki-light:#AB5959;--shiki-dark:#CB7676\">></span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\">operation:</span><span style=\"--shiki-light:#59873A;--shiki-dark:#80A665\"> Painting</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\"> the</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\"> Render</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\"> Tree</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#59873A;--shiki-dark:#80A665\">op-</span><span style=\"--shiki-light:#393A34;--shiki-dark:#DBD7CAEE\">></span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\">op1-</span><span style=\"--shiki-light:#393A34;--shiki-dark:#DBD7CAEE\">></span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\">op2-</span><span style=\"--shiki-light:#393A34;--shiki-dark:#DBD7CAEE\">></span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\">op3</span></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2 id=\"tcp-断开连接-四次挥手\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#tcp-断开连接-四次挥手\"><span>TCP 断开连接，四次挥手</span></a></h2>\n<p>现在的页面为了优化请求的耗时，默认都会开启持久连接（keep-alive），那么一个 TCP 连接确切关闭的时机，是这个 tab 标签页关闭的时候。</p>\n<p>这个关闭的过程就是著名的四次挥手。</p>\n<h3 id=\"tcp-四次挥手\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#tcp-四次挥手\"><span>TCP 四次挥手</span></a></h3>\n<p>关闭是一个全双工的过程，发包的顺序的不一定的。</p>\n<p>一般来说是客户端主动发起的关闭，过程如下。</p>\n<p>假如最后一次客户端发出的数据 seq = x, ack = y;</p>\n<ul>\n<li>客户端发送一个 FIN 置为 1 的包，ack = y， seq = x + 1，此时客户端的状态为 FIN_WAIT_1</li>\n<li>服务端收到包后，状态切换为 CLOSE_WAIT 发送一个 ACK 为 1 的包， ack = x + 2。客户端收到包之后状态切换为 FNI_WAIT_2</li>\n<li>服务端处理完任务后，向客户端发送一个 FIN 包，seq = y; 同时将自己的状态置为 LAST_ACK</li>\n<li>客户端收到包后状态切换为 TIME_WAIT，并向服务端发送 ACK 包，ack = y + 1，等待 2MSL 后关闭连接。</li>\n</ul>\n<h3 id=\"为什么客户端等待-2msl\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#为什么客户端等待-2msl\"><span>为什么客户端等待 2MSL？</span></a></h3>\n<p>MSL: 全程 Maximum Segment Lifetime，中文可以翻译为报文最大生存时间。</p>\n<p>等待是为了保证连接的可靠性，确保服务端收到 ACK 包，如果服务端没有收到这个 ACK 包，将会重发 FIN 包给客户端，而这个时间刚好是服务端等待超时重发的时间 + FIN 的传输时间。</p>\n</template>","contentStripped":"<p>整个过程的步骤：</p>\n<ol>\n<li>查看 DNS 缓存；命中缓存，则直接返回；没有缓存，往下进行</li>\n</ol>\n<ul>\n<li>浏览器缓存</li>\n<li>操作系统缓存</li>\n<li>路由器缓存</li>\n<li>ISP 缓存</li>\n</ul>\n<ol start=\"2\">\n<li>DNS 解析：将解析域名获取 IP 地址</li>\n<li>浏览器缓存：命中缓存，则直接返回，否则进行网络请求并渲染页面</li>\n<li>TCP 连接：通过 IP 向服务器发起 TCP 连接，TCP 三次握手</li>\n<li>向目标服务器发送 HTTP 请求报文，分析 url，设置请求报文头，报文主体</li>\n<li>服务器处理请求，并返回 HTTP 报文</li>\n<li>浏览器开始解析渲染页面并显示</li>\n<li>断开 TCP 连接：TCP 四次挥手</li>\n</ol>\n<h2 id=\"dns\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#dns\"><span>DNS</span></a></h2>\n<blockquote>\n<p>域名系统（英文：Domain Name System，缩写：DNS）是互联网的一项服务。</p>\n<p>它作为将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。</p>\n<p>DNS 使用 TCP 和 UDP 端口 53。</p>\n<p>当前，对于每一级域名长度的限制是 63 个字符，域名总长度则不能超过 253 个字符。</p>\n<p>--维基百科</p>\n</blockquote>\n<h3 id=\"域名解析的过程是逐级查询的\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#域名解析的过程是逐级查询的\"><span><font style=\"color:rgb(33, 37, 41);\">域名解析的过程是逐级查询的</font></span></a></h3>\n<h4 id=\"浏览器缓存\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#浏览器缓存\"><span><font style=\"color:rgb(33, 37, 41);\">浏览器缓存</font></span></a></h4>\n<font style=\"color:rgb(33, 37, 41);\">首先会向浏览器的缓存中读取上一次访问的记录，</font><font style=\"color:rgb(33, 37, 41);\">在 chrome 可以通过地址栏中输入 chrome://net-internals/#dns 查看 DNS 缓存的当前状态</font><h4 id=\"操作系统缓存\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#操作系统缓存\"><span><font style=\"color:rgb(33, 37, 41);\">操作系统缓存</font></span></a></h4>\n<font style=\"color:rgb(33, 37, 41);\">查找存储在系统运行内存中的缓存。</font><font style=\"color:rgb(33, 37, 41);\">过程：</font><ol>\n<li>\n<font style=\"color:rgb(33, 37, 41);\">在 host 文件中查找：如果在缓存中都查找不到的情况下，就会读取系统中预设的 host 文件中的设置。</font></li>\n<li>\n<font style=\"color:rgb(33, 37, 41);\">路由器缓存：有些路由器也有 DNS 缓存的功能，访问过的域名会存在路由器上。</font></li>\n<li>\n<font style=\"color:rgb(33, 37, 41);\">ISP DNS 缓存：互联网服务提供商（如中国电信）也会提供 DNS 服务，比如比较著名的 114.114.114.114，在本地查找不到的情况下，就会向 ISP 进行查询，ISP 会在当前服务器的缓存内查找是否有记录，如果有，则返回这个 IP，若没有，则会开始向根域名服务器请求查询。</font></li>\n<li>\n<font style=\"color:rgb(33, 37, 41);\">顶级 DNS 服务器/根 DNS 服务器：根域名收到请求后，会判别这个域名(.com)是授权给哪台服务器管理,并返回这个顶级 DNS 服务器的 IP。请求者收到这台顶级 DNS 的服务器 IP 后，会向该服务器发起查询，如果该服务器无法解析，该服务器就会返回下一级的 DNS 服务器 IP（nicefilm.com），本机继续查找，直到服务器找到(www.nicefilm.com)的主机。</font></li>\n</ol>\n<font style=\"color:rgb(33, 37, 41);\">MacOS</font><ul>\n<li><code v-pre>dscacheutil -flushcache</code><font style=\"color:rgb(33, 37, 41);\">清除系统中的 DNS 缓存</font></li>\n<li><code v-pre>dig 域名地址</code>查看域名解析的记录</li>\n</ul>\n<h2 id=\"tcp-连接-三次握手\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#tcp-连接-三次握手\"><span>TCP 连接，三次握手</span></a></h2>\n<p>拿到了要请求的资源服务器 IP 后，浏览器通过操作 OS 的 socket 与服务器进行 TCP 连接。</p>\n<h3 id=\"tcp-三次握手\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#tcp-三次握手\"><span>TCP 三次握手</span></a></h3>\n<p>本机主动打开连接：</p>\n<ul>\n<li>第一次，本机将标识位 SYN 置为 1, seq = x(Sequence number)发送给服务端。此时本机状态为 SYN-SENT</li>\n<li>第二次，服务器收到包之后，将状态切换为 SYN-RECEIVED，并将标识位 SYN 和 ACK 都置为 1, seq = y, ack = x + 1, 并发送给客户端。</li>\n<li>第三次，客户端收到包后，将状态切换为 ESTABLISHED，并将标识位 ACK 置为 1，seq = x + 1, ack = y + 1, 并发送给服务端。服务端收到包之后，也将状态切换为 ESTABLISHED。</li>\n</ul>\n<h3 id=\"理解\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#理解\"><span>理解</span></a></h3>\n<ul>\n<li>标识位 ACK 置为 1 表示我已确认收到 seq 为 x 的包，并回复确认序号 ack = x + 1</li>\n<li>SYN 表示这是我第一次随机生成 seq 的序列 x，此后我每次发送的包都会在上一次发送的基础上增加 y（有数据的时候，y 是数据的长度，没有的时候 y = 1）。所以，当 seq 已初始化完成之后，没必要再把 SYN 置为 1</li>\n</ul>\n<p>理解了这两点，也就不难理解为什么三次握手分别是 SYN、ACK/SYN、ACK 了。</p>\n<p><strong>标识位（TCP FLAG）</strong></p>\n<p>TCP 的头部固定有 20 个字节，其中分配了 6bits 给 TCP FLAG，组合起来用来表示当前包的类型。</p>\n<p>分别是 URG ACK PSH RST SYN FIN</p>\n<ul>\n<li>URG：紧急指针，用于将要发送的包标识为“紧急”，这意味着不必等待前段数据被响应处理完即可发送给接收端。</li>\n<li>ACK：确认标识，用于表示对数据包的成功接收。</li>\n<li>PSH：推送标识，表示这个数据包应该被立即发送，不需要等待额外的数据。</li>\n<li>RST：reset 标识，用来异常关闭连接。</li>\n<li>SYN：同步标识，表示 TCP 连接已初始化。</li>\n<li>FIN：完成标识，用于拆除上一个 SYN 标识。一个完整的 TCP 连接过程一定会有 SYN 和 FIN 包。</li>\n</ul>\n<p>至此我们了解了一个 TCP 连接的过程，通道通了，是时候利用这个通道送东西了。</p>\n<p>我们从传输层再回到应用层。</p>\n<h2 id=\"http-请求与响应\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#http-请求与响应\"><span>HTTP 请求与响应</span></a></h2>\n<blockquote>\n<p>超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。</p>\n<p>HTTP 是万维网的数据通信的基础。</p>\n<p>设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。</p>\n<p>通过 HTTP 或者 HTTPS 协议请求的资源由统一资源标识符（Uniform Resource Identifiers，URI）来标识。</p>\n<font style=\"color:rgb(33, 37, 41);\">--维基百科</font></blockquote>\n<h3 id=\"http-请求\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#http-请求\"><span>http 请求</span></a></h3>\n<p>在应用层，浏览器会分析这个 url，并设置好请求报文发出。</p>\n<p>https 默认请求端口 443， http 默认 80。</p>\n<p>请求报文中包括请求行、请求头、空行、请求主体。</p>\n<ul>\n<li>请求行：请求行中包括请求的方法，路径和协议版本。</li>\n<li>请求头：请求头中包含了请求的一些附加的信息，一般是以键值的形式成对存在，比如设置请求文件的类型 accept-type，以及服务器对缓存的设置。</li>\n<li>空行：协议中规定请求头和请求主体间必须用一个空行隔开</li>\n<li>请求主体：对于 post 请求，所需要的参数都不会放在 url 中，这时候就需要一个载体了，这个载体就是请求主题。</li>\n</ul>\n<h3 id=\"http-响应\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#http-响应\"><span>http 响应</span></a></h3>\n<p>服务端收到请求之后，会根据 url 匹配到的路径做相应的处理，最后返回浏览器需要的页面资源。</p>\n<p>浏览器会收到一个响应报文，而所需要的资源就就在报文主体上。</p>\n<p>与请求报文相同，响应报文也有与之对应的起始行、首部、空行、报文主体，不同的地方在于包含的东西不一样。</p>\n<ul>\n<li>响应行：响应报文的起始行同样包含了协议版本，与请求的起始行不同的是其包含的还有状态码和状态码的原因短语。</li>\n<li>响应头：对应请求报文中的请求头，格式一致，但是各自有不同的首部。也有一起用的通用首部。</li>\n<li>空行</li>\n<li>报文主体：请求所需要的资源。</li>\n</ul>\n<h2 id=\"浏览器渲染\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#浏览器渲染\"><span>浏览器渲染</span></a></h2>\n<font style=\"color:rgb(33, 37, 41);\">浏览器拿到了一个 HTML 文档，并为了呈现文档而开始解析。</font><font style=\"color:rgb(33, 37, 41);\">呈现引擎开始工作，基本流程如下:</font><ul>\n<li>\n<font style=\"color:rgb(33, 37, 41);\">通过 HTML 解析器解析 HTML 文档，</font><ul>\n<li>\n<font style=\"color:rgb(33, 37, 41);\">构建一个 DOM Tree</font></li>\n<li>\n<font style=\"color:rgb(33, 37, 41);\">同时通过 CSS 解析器解析 HTML 中存在的 CSS，构建 Style Rules</font></li>\n<li>\n<font style=\"color:rgb(33, 37, 41);\">两者结合形成一个 Attachment</font></li>\n</ul>\n</li>\n<li>\n<font style=\"color:rgb(33, 37, 41);\">通过 Attachment 构造出一个呈现树（Render Tree）</font></li>\n<li>\n<font style=\"color:rgb(33, 37, 41);\">Render Tree 构建完毕，进入到布局阶段（layout/reflow），将会为每个阶段分配一个应出现在屏幕上的确切坐标。</font></li>\n<li>\n<font style=\"color:rgb(33, 37, 41);\">最后将全部的节点遍历绘制出来后，一个页面就展现出来了。</font></li>\n</ul>\n<font style=\"color:rgb(33, 37, 41);\"></font><font style=\"color:rgb(33, 37, 41);\">从构建 DOM 树到呈现的过程如下</font><div class=\"language-bash line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"bash\" style=\"--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212\"><pre class=\"shiki shiki-themes vitesse-light vitesse-dark vp-code\" v-pre=\"\"><code class=\"language-bash\"><span class=\"line\"><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">op</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">=</span><span style=\"--shiki-light:#AB5959;--shiki-dark:#CB7676\">></span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\">operation:</span><span style=\"--shiki-light:#59873A;--shiki-dark:#80A665\"> Parsing</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\"> HTML</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\"> to</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\"> construct</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\"> the</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\"> DOM</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\"> tree</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">op1</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">=</span><span style=\"--shiki-light:#AB5959;--shiki-dark:#CB7676\">></span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\">operation:</span><span style=\"--shiki-light:#59873A;--shiki-dark:#80A665\"> Render</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\"> Tree</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\"> construction</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">op2</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">=</span><span style=\"--shiki-light:#AB5959;--shiki-dark:#CB7676\">></span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\">operation:</span><span style=\"--shiki-light:#59873A;--shiki-dark:#80A665\"> Layout</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\"> of</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\"> the</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\"> Render</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\"> Tree</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">op3</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">=</span><span style=\"--shiki-light:#AB5959;--shiki-dark:#CB7676\">></span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\">operation:</span><span style=\"--shiki-light:#59873A;--shiki-dark:#80A665\"> Painting</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\"> the</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\"> Render</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\"> Tree</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#59873A;--shiki-dark:#80A665\">op-</span><span style=\"--shiki-light:#393A34;--shiki-dark:#DBD7CAEE\">></span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\">op1-</span><span style=\"--shiki-light:#393A34;--shiki-dark:#DBD7CAEE\">></span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\">op2-</span><span style=\"--shiki-light:#393A34;--shiki-dark:#DBD7CAEE\">></span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\">op3</span></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2 id=\"tcp-断开连接-四次挥手\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#tcp-断开连接-四次挥手\"><span>TCP 断开连接，四次挥手</span></a></h2>\n<p>现在的页面为了优化请求的耗时，默认都会开启持久连接（keep-alive），那么一个 TCP 连接确切关闭的时机，是这个 tab 标签页关闭的时候。</p>\n<p>这个关闭的过程就是著名的四次挥手。</p>\n<h3 id=\"tcp-四次挥手\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#tcp-四次挥手\"><span>TCP 四次挥手</span></a></h3>\n<p>关闭是一个全双工的过程，发包的顺序的不一定的。</p>\n<p>一般来说是客户端主动发起的关闭，过程如下。</p>\n<p>假如最后一次客户端发出的数据 seq = x, ack = y;</p>\n<ul>\n<li>客户端发送一个 FIN 置为 1 的包，ack = y， seq = x + 1，此时客户端的状态为 FIN_WAIT_1</li>\n<li>服务端收到包后，状态切换为 CLOSE_WAIT 发送一个 ACK 为 1 的包， ack = x + 2。客户端收到包之后状态切换为 FNI_WAIT_2</li>\n<li>服务端处理完任务后，向客户端发送一个 FIN 包，seq = y; 同时将自己的状态置为 LAST_ACK</li>\n<li>客户端收到包后状态切换为 TIME_WAIT，并向服务端发送 ACK 包，ack = y + 1，等待 2MSL 后关闭连接。</li>\n</ul>\n<h3 id=\"为什么客户端等待-2msl\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#为什么客户端等待-2msl\"><span>为什么客户端等待 2MSL？</span></a></h3>\n<p>MSL: 全程 Maximum Segment Lifetime，中文可以翻译为报文最大生存时间。</p>\n<p>等待是为了保证连接的可靠性，确保服务端收到 ACK 包，如果服务端没有收到这个 ACK 包，将会重发 FIN 包给客户端，而这个时间刚好是服务端等待超时重发的时间 + FIN 的传输时间。</p>\n","tagOpen":"<template>","tagClose":"</template>"},"script":null,"scriptSetup":null,"scripts":[],"styles":[],"customBlocks":[]},"content":"\n整个过程的步骤：\n\n1. 查看 DNS 缓存；命中缓存，则直接返回；没有缓存，往下进行\n\n- 浏览器缓存\n- 操作系统缓存\n- 路由器缓存\n- ISP 缓存\n\n2. DNS 解析：将解析域名获取 IP 地址\n3. 浏览器缓存：命中缓存，则直接返回，否则进行网络请求并渲染页面\n4. TCP 连接：通过 IP 向服务器发起 TCP 连接，TCP 三次握手\n5. 向目标服务器发送 HTTP 请求报文，分析 url，设置请求报文头，报文主体\n6. 服务器处理请求，并返回 HTTP 报文\n7. 浏览器开始解析渲染页面并显示\n8. 断开 TCP 连接：TCP 四次挥手\n\n## DNS\n\n> 域名系统（英文：Domain Name System，缩写：DNS）是互联网的一项服务。\n>\n> 它作为将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。\n>\n> DNS 使用 TCP 和 UDP 端口 53。\n>\n> 当前，对于每一级域名长度的限制是 63 个字符，域名总长度则不能超过 253 个字符。\n>\n> --维基百科\n\n### <font style=\"color:rgb(33, 37, 41);\">域名解析的过程是逐级查询的</font>\n\n#### <font style=\"color:rgb(33, 37, 41);\">浏览器缓存</font>\n\n<font style=\"color:rgb(33, 37, 41);\">首先会向浏览器的缓存中读取上一次访问的记录，</font>\n\n<font style=\"color:rgb(33, 37, 41);\">在 chrome 可以通过地址栏中输入 chrome://net-internals/#dns 查看 DNS 缓存的当前状态</font>\n\n#### <font style=\"color:rgb(33, 37, 41);\">操作系统缓存</font>\n\n<font style=\"color:rgb(33, 37, 41);\">查找存储在系统运行内存中的缓存。</font>\n\n<font style=\"color:rgb(33, 37, 41);\">过程：</font>\n\n1. <font style=\"color:rgb(33, 37, 41);\">在 host 文件中查找：如果在缓存中都查找不到的情况下，就会读取系统中预设的 host 文件中的设置。</font>\n2. <font style=\"color:rgb(33, 37, 41);\">路由器缓存：有些路由器也有 DNS 缓存的功能，访问过的域名会存在路由器上。</font>\n3. <font style=\"color:rgb(33, 37, 41);\">ISP DNS 缓存：互联网服务提供商（如中国电信）也会提供 DNS 服务，比如比较著名的 114.114.114.114，在本地查找不到的情况下，就会向 ISP 进行查询，ISP 会在当前服务器的缓存内查找是否有记录，如果有，则返回这个 IP，若没有，则会开始向根域名服务器请求查询。</font>\n4. <font style=\"color:rgb(33, 37, 41);\">顶级 DNS 服务器/根 DNS 服务器：根域名收到请求后，会判别这个域名(.com)是授权给哪台服务器管理,并返回这个顶级 DNS 服务器的 IP。请求者收到这台顶级 DNS 的服务器 IP 后，会向该服务器发起查询，如果该服务器无法解析，该服务器就会返回下一级的 DNS 服务器 IP（nicefilm.com），本机继续查找，直到服务器找到(www.nicefilm.com)的主机。</font>\n\n<font style=\"color:rgb(33, 37, 41);\">MacOS</font>\n\n- `dscacheutil -flushcache`<font style=\"color:rgb(33, 37, 41);\">清除系统中的 DNS 缓存</font>\n- `dig 域名地址`查看域名解析的记录\n\n## TCP 连接，三次握手\n\n拿到了要请求的资源服务器 IP 后，浏览器通过操作 OS 的 socket 与服务器进行 TCP 连接。\n\n### TCP 三次握手\n\n本机主动打开连接：\n\n- 第一次，本机将标识位 SYN 置为 1, seq = x(Sequence number)发送给服务端。此时本机状态为 SYN-SENT\n- 第二次，服务器收到包之后，将状态切换为 SYN-RECEIVED，并将标识位 SYN 和 ACK 都置为 1, seq = y, ack = x + 1, 并发送给客户端。\n- 第三次，客户端收到包后，将状态切换为 ESTABLISHED，并将标识位 ACK 置为 1，seq = x + 1, ack = y + 1, 并发送给服务端。服务端收到包之后，也将状态切换为 ESTABLISHED。\n\n### 理解\n\n- 标识位 ACK 置为 1 表示我已确认收到 seq 为 x 的包，并回复确认序号 ack = x + 1\n- SYN 表示这是我第一次随机生成 seq 的序列 x，此后我每次发送的包都会在上一次发送的基础上增加 y（有数据的时候，y 是数据的长度，没有的时候 y = 1）。所以，当 seq 已初始化完成之后，没必要再把 SYN 置为 1\n\n理解了这两点，也就不难理解为什么三次握手分别是 SYN、ACK/SYN、ACK 了。\n\n**标识位（TCP FLAG）**\n\nTCP 的头部固定有 20 个字节，其中分配了 6bits 给 TCP FLAG，组合起来用来表示当前包的类型。\n\n分别是 URG ACK PSH RST SYN FIN\n\n- URG：紧急指针，用于将要发送的包标识为“紧急”，这意味着不必等待前段数据被响应处理完即可发送给接收端。\n- ACK：确认标识，用于表示对数据包的成功接收。\n- PSH：推送标识，表示这个数据包应该被立即发送，不需要等待额外的数据。\n- RST：reset 标识，用来异常关闭连接。\n- SYN：同步标识，表示 TCP 连接已初始化。\n- FIN：完成标识，用于拆除上一个 SYN 标识。一个完整的 TCP 连接过程一定会有 SYN 和 FIN 包。\n\n至此我们了解了一个 TCP 连接的过程，通道通了，是时候利用这个通道送东西了。\n\n我们从传输层再回到应用层。\n\n## HTTP 请求与响应\n\n> 超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。\n>\n> HTTP 是万维网的数据通信的基础。\n>\n> 设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。\n>\n> 通过 HTTP 或者 HTTPS 协议请求的资源由统一资源标识符（Uniform Resource Identifiers，URI）来标识。\n>\n> <font style=\"color:rgb(33, 37, 41);\">--维基百科</font>\n\n### http 请求\n\n在应用层，浏览器会分析这个 url，并设置好请求报文发出。\n\nhttps 默认请求端口 443， http 默认 80。\n\n请求报文中包括请求行、请求头、空行、请求主体。\n\n- 请求行：请求行中包括请求的方法，路径和协议版本。\n- 请求头：请求头中包含了请求的一些附加的信息，一般是以键值的形式成对存在，比如设置请求文件的类型 accept-type，以及服务器对缓存的设置。\n- 空行：协议中规定请求头和请求主体间必须用一个空行隔开\n- 请求主体：对于 post 请求，所需要的参数都不会放在 url 中，这时候就需要一个载体了，这个载体就是请求主题。\n\n### http 响应\n\n服务端收到请求之后，会根据 url 匹配到的路径做相应的处理，最后返回浏览器需要的页面资源。\n\n浏览器会收到一个响应报文，而所需要的资源就就在报文主体上。\n\n与请求报文相同，响应报文也有与之对应的起始行、首部、空行、报文主体，不同的地方在于包含的东西不一样。\n\n- 响应行：响应报文的起始行同样包含了协议版本，与请求的起始行不同的是其包含的还有状态码和状态码的原因短语。\n- 响应头：对应请求报文中的请求头，格式一致，但是各自有不同的首部。也有一起用的通用首部。\n- 空行\n- 报文主体：请求所需要的资源。\n\n## 浏览器渲染\n\n<font style=\"color:rgb(33, 37, 41);\">浏览器拿到了一个 HTML 文档，并为了呈现文档而开始解析。</font>\n\n<font style=\"color:rgb(33, 37, 41);\">呈现引擎开始工作，基本流程如下:</font>\n\n- <font style=\"color:rgb(33, 37, 41);\">通过 HTML 解析器解析 HTML 文档，</font>\n  - <font style=\"color:rgb(33, 37, 41);\">构建一个 DOM Tree</font>\n  - <font style=\"color:rgb(33, 37, 41);\">同时通过 CSS 解析器解析 HTML 中存在的 CSS，构建 Style Rules</font>\n  - <font style=\"color:rgb(33, 37, 41);\">两者结合形成一个 Attachment</font>\n- <font style=\"color:rgb(33, 37, 41);\">通过 Attachment 构造出一个呈现树（Render Tree）</font>\n- <font style=\"color:rgb(33, 37, 41);\">Render Tree 构建完毕，进入到布局阶段（layout/reflow），将会为每个阶段分配一个应出现在屏幕上的确切坐标。</font>\n- <font style=\"color:rgb(33, 37, 41);\">最后将全部的节点遍历绘制出来后，一个页面就展现出来了。</font>\n\n<font style=\"color:rgb(33, 37, 41);\"></font>\n\n<font style=\"color:rgb(33, 37, 41);\">从构建 DOM 树到呈现的过程如下</font>\n\n```bash\nop=>operation: Parsing HTML to construct the DOM tree\nop1=>operation: Render Tree construction\nop2=>operation: Layout of the Render Tree\nop3=>operation: Painting the Render Tree\nop->op1->op2->op3\n```\n\n## TCP 断开连接，四次挥手\n\n现在的页面为了优化请求的耗时，默认都会开启持久连接（keep-alive），那么一个 TCP 连接确切关闭的时机，是这个 tab 标签页关闭的时候。\n\n这个关闭的过程就是著名的四次挥手。\n\n### TCP 四次挥手\n\n关闭是一个全双工的过程，发包的顺序的不一定的。\n\n一般来说是客户端主动发起的关闭，过程如下。\n\n假如最后一次客户端发出的数据 seq = x, ack = y;\n\n- 客户端发送一个 FIN 置为 1 的包，ack = y， seq = x + 1，此时客户端的状态为 FIN_WAIT_1\n- 服务端收到包后，状态切换为 CLOSE_WAIT 发送一个 ACK 为 1 的包， ack = x + 2。客户端收到包之后状态切换为 FNI_WAIT_2\n- 服务端处理完任务后，向客户端发送一个 FIN 包，seq = y; 同时将自己的状态置为 LAST_ACK\n- 客户端收到包后状态切换为 TIME_WAIT，并向服务端发送 ACK 包，ack = y + 1，等待 2MSL 后关闭连接。\n\n### 为什么客户端等待 2MSL？\n\nMSL: 全程 Maximum Segment Lifetime，中文可以翻译为报文最大生存时间。\n\n等待是为了保证连接的可靠性，确保服务端收到 ACK 包，如果服务端没有收到这个 ACK 包，将会重发 FIN 包给客户端，而这个时间刚好是服务端等待超时重发的时间 + FIN 的传输时间。","excerpt":"","includedFiles":[],"tasklistId":0,"title":"","headers":[{"level":2,"title":"DNS","slug":"dns","link":"#dns","children":[{"level":3,"title":"域名解析的过程是逐级查询的","slug":"域名解析的过程是逐级查询的","link":"#域名解析的过程是逐级查询的","children":[]}]},{"level":2,"title":"TCP 连接，三次握手","slug":"tcp-连接-三次握手","link":"#tcp-连接-三次握手","children":[{"level":3,"title":"TCP 三次握手","slug":"tcp-三次握手","link":"#tcp-三次握手","children":[]},{"level":3,"title":"理解","slug":"理解","link":"#理解","children":[]}]},{"level":2,"title":"HTTP 请求与响应","slug":"http-请求与响应","link":"#http-请求与响应","children":[{"level":3,"title":"http 请求","slug":"http-请求","link":"#http-请求","children":[]},{"level":3,"title":"http 响应","slug":"http-响应","link":"#http-响应","children":[]}]},{"level":2,"title":"浏览器渲染","slug":"浏览器渲染","link":"#浏览器渲染","children":[]},{"level":2,"title":"TCP 断开连接，四次挥手","slug":"tcp-断开连接-四次挥手","link":"#tcp-断开连接-四次挥手","children":[{"level":3,"title":"TCP 四次挥手","slug":"tcp-四次挥手","link":"#tcp-四次挥手","children":[]},{"level":3,"title":"为什么客户端等待 2MSL？","slug":"为什么客户端等待-2msl","link":"#为什么客户端等待-2msl","children":[]}]}]}}
