{"content":"<blockquote>\n<ul>\n<li>Fast, disk space efficient package manager</li>\n<li>快，节省磁盘空间，的 package 管理器</li>\n</ul>\n</blockquote>\n<p>相关链接</p>\n<ul>\n<li><VPLink href=\"!https://www.pnpm.cn/\">pnpm 中文网</VPLink></li>\n</ul>\n<h2 id=\"高效利用磁盘空间\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#高效利用磁盘空间\"><span>高效利用磁盘空间</span></a></h2>\n<p>硬链接(Hard Link)</p>\n<div class=\"language- line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"\" style=\"--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212\"><pre class=\"shiki shiki-themes vitesse-light vitesse-dark vp-code\" v-pre=\"\"><code class=\"language-\"><span class=\"line\"><span>硬连接指通过索引节点来进行连接。</span></span>\n<span class=\"line\"><span>在Linux的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。</span></span>\n<span class=\"line\"><span>在Linux中，多个文件名指向同一索引节点是存在的。一般这种连接就是硬连接。</span></span>\n<span class=\"line\"><span>硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。</span></span>\n<span class=\"line\"><span>只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。</span></span>\n<span class=\"line\"><span>也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。</span></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>软连接(Symbolic Link)</p>\n<div class=\"language- line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"\" style=\"--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212\"><pre class=\"shiki shiki-themes vitesse-light vitesse-dark vp-code\" v-pre=\"\"><code class=\"language-\"><span class=\"line\"><span>另外一种连接称之为符号连接，也叫软连接。</span></span>\n<span class=\"line\"><span>软链接文件有类似于Windows的快捷方式。</span></span>\n<span class=\"line\"><span>它实际上是一个特殊的文件。</span></span>\n<span class=\"line\"><span>在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。</span></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2 id=\"支持-monorepo\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#支持-monorepo\"><span>支持 monorepo</span></a></h2>\n<p>monorepo 的宗旨就是用一个 git 仓库来管理多个子项目，所有的子项目都存放在根目录的 packages 目录下，那么一个子项目就代表一个 package。</p>\n<p>monorepo 管理工具 <code v-pre>lerna</code></p>\n<p>项目参考：<code v-pre>babel</code></p>\n<h2 id=\"安全\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#安全\"><span>安全</span></a></h2>\n<p>之前在使用 npm/yarn 的时候，由于 node_module 的扁平结构，如果 A 依赖 B， B 依赖 C，那么 A 当中是可以直接使用 C 的，但问题是 A 当中并没有声明 C 这个依赖。</p>\n<p>因此会出现这种非法访问的情况。</p>\n<p>但 pnpm 自创了一套依赖管理方式，很好地解决了这个问题，保证了安全性。</p>\n<blockquote>\n<p><VPLink href=\"!./nodeModules.md\">node_modules 结构历史</VPLink></p>\n</blockquote>\n<h2 id=\"不适用的场景\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#不适用的场景\"><span>不适用的场景</span></a></h2>\n<p>前面有提到关于 pnpm 的主要问题在于 symlink(软链接)在一些场景下会存在兼容的问题，可以参考作者在 nodejs 那边开的一个 <a href=\"https://github.com/nodejs/node/discussions/37509\" target=\"_blank\" rel=\"noopener noreferrer\">node discussion</a></p>\n<p>在里面作者提到了目前 nodejs 软连接不能适用的一些场景，希望 nodejs 能提供一种 link 方式而不是使用软连接，同时也提到了 pnpm 目前因为软连接而不能使用的场景:</p>\n<ul>\n<li>Electron 应用无法使用 pnpm</li>\n<li>部署在 lambda 上的应用无法使用 pnpm</li>\n<li>一些 nodejs 基础库不支持 symlink 的情况导致使用 pnpm 无法正常工作，不过这些库在迭代更新之后也会支持这一特性。</li>\n</ul>\n<h2 id=\"未来会做的一些事情\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#未来会做的一些事情\"><span>未来会做的一些事情</span></a></h2>\n<h3 id=\"脱离-node-js\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#脱离-node-js\"><span>脱离 Node.js</span></a></h3>\n<p>具体可以参考 <a href=\"https://github.com/pnpm/pnpm/discussions/3434\" target=\"_blank\" rel=\"noopener noreferrer\">pnpm discussions</a></p>\n<p>安装 pnpm 的， 可以基本上脱离掉 nodejs 这个 runtime 去进行安装使用。</p>\n<p>可以通过 pnpm 来使用不同版本的 nodejs 来去做依赖安装，类似于 nvm 提供的功能。</p>\n<p>目前该特性其实已经到了 <a href=\"https://www.npmjs.com/package/@pnpm/beta\" target=\"_blank\" rel=\"noopener noreferrer\">beta 版本</a>，可以参考这个包。</p>\n<p>管理不同版本的 nodejs 功能可以参考 env 这个子命令: <a href=\"https://pnpm.io/cli/env\" target=\"_blank\" rel=\"noopener noreferrer\">pnpm-cli-env</a></p>\n<h3 id=\"使用-rust-写一些模块\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#使用-rust-写一些模块\"><span>使用 rust 写一些模块</span></a></h3>\n<p>具体可以看<a href=\"https://github.com/pnpm/pnpm/discussions/3419\" target=\"_blank\" rel=\"noopener noreferrer\">pnpm discussion</a>讨论的内容，大概就是作者希望给 pnpm 的一些子命令提供一些 rust 的 cli wrapper 来做提升性能使用。</p>\n","env":{"base":"/blog/","filePath":"/Users/wangzhijie/Desktop/myspace/wangzhije.github.io/docs/notes/2.nodejs/2.包管理/4.pnpm.md","filePathRelative":"notes/2.nodejs/2.包管理/4.pnpm.md","frontmatter":{"title":"pnpm","createTime":"2025/08/14 23:23:11","permalink":"/nodejs/package/4t9ndsf8/","tag":["Node.js","pnpm"]},"sfcBlocks":{"template":{"type":"template","content":"<template><blockquote>\n<ul>\n<li>Fast, disk space efficient package manager</li>\n<li>快，节省磁盘空间，的 package 管理器</li>\n</ul>\n</blockquote>\n<p>相关链接</p>\n<ul>\n<li><VPLink href=\"!https://www.pnpm.cn/\">pnpm 中文网</VPLink></li>\n</ul>\n<h2 id=\"高效利用磁盘空间\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#高效利用磁盘空间\"><span>高效利用磁盘空间</span></a></h2>\n<p>硬链接(Hard Link)</p>\n<div class=\"language- line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"\" style=\"--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212\"><pre class=\"shiki shiki-themes vitesse-light vitesse-dark vp-code\" v-pre=\"\"><code class=\"language-\"><span class=\"line\"><span>硬连接指通过索引节点来进行连接。</span></span>\n<span class=\"line\"><span>在Linux的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。</span></span>\n<span class=\"line\"><span>在Linux中，多个文件名指向同一索引节点是存在的。一般这种连接就是硬连接。</span></span>\n<span class=\"line\"><span>硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。</span></span>\n<span class=\"line\"><span>只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。</span></span>\n<span class=\"line\"><span>也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。</span></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>软连接(Symbolic Link)</p>\n<div class=\"language- line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"\" style=\"--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212\"><pre class=\"shiki shiki-themes vitesse-light vitesse-dark vp-code\" v-pre=\"\"><code class=\"language-\"><span class=\"line\"><span>另外一种连接称之为符号连接，也叫软连接。</span></span>\n<span class=\"line\"><span>软链接文件有类似于Windows的快捷方式。</span></span>\n<span class=\"line\"><span>它实际上是一个特殊的文件。</span></span>\n<span class=\"line\"><span>在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。</span></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2 id=\"支持-monorepo\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#支持-monorepo\"><span>支持 monorepo</span></a></h2>\n<p>monorepo 的宗旨就是用一个 git 仓库来管理多个子项目，所有的子项目都存放在根目录的 packages 目录下，那么一个子项目就代表一个 package。</p>\n<p>monorepo 管理工具 <code v-pre>lerna</code></p>\n<p>项目参考：<code v-pre>babel</code></p>\n<h2 id=\"安全\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#安全\"><span>安全</span></a></h2>\n<p>之前在使用 npm/yarn 的时候，由于 node_module 的扁平结构，如果 A 依赖 B， B 依赖 C，那么 A 当中是可以直接使用 C 的，但问题是 A 当中并没有声明 C 这个依赖。</p>\n<p>因此会出现这种非法访问的情况。</p>\n<p>但 pnpm 自创了一套依赖管理方式，很好地解决了这个问题，保证了安全性。</p>\n<blockquote>\n<p><VPLink href=\"!./nodeModules.md\">node_modules 结构历史</VPLink></p>\n</blockquote>\n<h2 id=\"不适用的场景\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#不适用的场景\"><span>不适用的场景</span></a></h2>\n<p>前面有提到关于 pnpm 的主要问题在于 symlink(软链接)在一些场景下会存在兼容的问题，可以参考作者在 nodejs 那边开的一个 <a href=\"https://github.com/nodejs/node/discussions/37509\" target=\"_blank\" rel=\"noopener noreferrer\">node discussion</a></p>\n<p>在里面作者提到了目前 nodejs 软连接不能适用的一些场景，希望 nodejs 能提供一种 link 方式而不是使用软连接，同时也提到了 pnpm 目前因为软连接而不能使用的场景:</p>\n<ul>\n<li>Electron 应用无法使用 pnpm</li>\n<li>部署在 lambda 上的应用无法使用 pnpm</li>\n<li>一些 nodejs 基础库不支持 symlink 的情况导致使用 pnpm 无法正常工作，不过这些库在迭代更新之后也会支持这一特性。</li>\n</ul>\n<h2 id=\"未来会做的一些事情\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#未来会做的一些事情\"><span>未来会做的一些事情</span></a></h2>\n<h3 id=\"脱离-node-js\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#脱离-node-js\"><span>脱离 Node.js</span></a></h3>\n<p>具体可以参考 <a href=\"https://github.com/pnpm/pnpm/discussions/3434\" target=\"_blank\" rel=\"noopener noreferrer\">pnpm discussions</a></p>\n<p>安装 pnpm 的， 可以基本上脱离掉 nodejs 这个 runtime 去进行安装使用。</p>\n<p>可以通过 pnpm 来使用不同版本的 nodejs 来去做依赖安装，类似于 nvm 提供的功能。</p>\n<p>目前该特性其实已经到了 <a href=\"https://www.npmjs.com/package/@pnpm/beta\" target=\"_blank\" rel=\"noopener noreferrer\">beta 版本</a>，可以参考这个包。</p>\n<p>管理不同版本的 nodejs 功能可以参考 env 这个子命令: <a href=\"https://pnpm.io/cli/env\" target=\"_blank\" rel=\"noopener noreferrer\">pnpm-cli-env</a></p>\n<h3 id=\"使用-rust-写一些模块\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#使用-rust-写一些模块\"><span>使用 rust 写一些模块</span></a></h3>\n<p>具体可以看<a href=\"https://github.com/pnpm/pnpm/discussions/3419\" target=\"_blank\" rel=\"noopener noreferrer\">pnpm discussion</a>讨论的内容，大概就是作者希望给 pnpm 的一些子命令提供一些 rust 的 cli wrapper 来做提升性能使用。</p>\n</template>","contentStripped":"<blockquote>\n<ul>\n<li>Fast, disk space efficient package manager</li>\n<li>快，节省磁盘空间，的 package 管理器</li>\n</ul>\n</blockquote>\n<p>相关链接</p>\n<ul>\n<li><VPLink href=\"!https://www.pnpm.cn/\">pnpm 中文网</VPLink></li>\n</ul>\n<h2 id=\"高效利用磁盘空间\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#高效利用磁盘空间\"><span>高效利用磁盘空间</span></a></h2>\n<p>硬链接(Hard Link)</p>\n<div class=\"language- line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"\" style=\"--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212\"><pre class=\"shiki shiki-themes vitesse-light vitesse-dark vp-code\" v-pre=\"\"><code class=\"language-\"><span class=\"line\"><span>硬连接指通过索引节点来进行连接。</span></span>\n<span class=\"line\"><span>在Linux的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。</span></span>\n<span class=\"line\"><span>在Linux中，多个文件名指向同一索引节点是存在的。一般这种连接就是硬连接。</span></span>\n<span class=\"line\"><span>硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。</span></span>\n<span class=\"line\"><span>只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。</span></span>\n<span class=\"line\"><span>也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。</span></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>软连接(Symbolic Link)</p>\n<div class=\"language- line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"\" style=\"--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212\"><pre class=\"shiki shiki-themes vitesse-light vitesse-dark vp-code\" v-pre=\"\"><code class=\"language-\"><span class=\"line\"><span>另外一种连接称之为符号连接，也叫软连接。</span></span>\n<span class=\"line\"><span>软链接文件有类似于Windows的快捷方式。</span></span>\n<span class=\"line\"><span>它实际上是一个特殊的文件。</span></span>\n<span class=\"line\"><span>在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。</span></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2 id=\"支持-monorepo\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#支持-monorepo\"><span>支持 monorepo</span></a></h2>\n<p>monorepo 的宗旨就是用一个 git 仓库来管理多个子项目，所有的子项目都存放在根目录的 packages 目录下，那么一个子项目就代表一个 package。</p>\n<p>monorepo 管理工具 <code v-pre>lerna</code></p>\n<p>项目参考：<code v-pre>babel</code></p>\n<h2 id=\"安全\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#安全\"><span>安全</span></a></h2>\n<p>之前在使用 npm/yarn 的时候，由于 node_module 的扁平结构，如果 A 依赖 B， B 依赖 C，那么 A 当中是可以直接使用 C 的，但问题是 A 当中并没有声明 C 这个依赖。</p>\n<p>因此会出现这种非法访问的情况。</p>\n<p>但 pnpm 自创了一套依赖管理方式，很好地解决了这个问题，保证了安全性。</p>\n<blockquote>\n<p><VPLink href=\"!./nodeModules.md\">node_modules 结构历史</VPLink></p>\n</blockquote>\n<h2 id=\"不适用的场景\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#不适用的场景\"><span>不适用的场景</span></a></h2>\n<p>前面有提到关于 pnpm 的主要问题在于 symlink(软链接)在一些场景下会存在兼容的问题，可以参考作者在 nodejs 那边开的一个 <a href=\"https://github.com/nodejs/node/discussions/37509\" target=\"_blank\" rel=\"noopener noreferrer\">node discussion</a></p>\n<p>在里面作者提到了目前 nodejs 软连接不能适用的一些场景，希望 nodejs 能提供一种 link 方式而不是使用软连接，同时也提到了 pnpm 目前因为软连接而不能使用的场景:</p>\n<ul>\n<li>Electron 应用无法使用 pnpm</li>\n<li>部署在 lambda 上的应用无法使用 pnpm</li>\n<li>一些 nodejs 基础库不支持 symlink 的情况导致使用 pnpm 无法正常工作，不过这些库在迭代更新之后也会支持这一特性。</li>\n</ul>\n<h2 id=\"未来会做的一些事情\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#未来会做的一些事情\"><span>未来会做的一些事情</span></a></h2>\n<h3 id=\"脱离-node-js\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#脱离-node-js\"><span>脱离 Node.js</span></a></h3>\n<p>具体可以参考 <a href=\"https://github.com/pnpm/pnpm/discussions/3434\" target=\"_blank\" rel=\"noopener noreferrer\">pnpm discussions</a></p>\n<p>安装 pnpm 的， 可以基本上脱离掉 nodejs 这个 runtime 去进行安装使用。</p>\n<p>可以通过 pnpm 来使用不同版本的 nodejs 来去做依赖安装，类似于 nvm 提供的功能。</p>\n<p>目前该特性其实已经到了 <a href=\"https://www.npmjs.com/package/@pnpm/beta\" target=\"_blank\" rel=\"noopener noreferrer\">beta 版本</a>，可以参考这个包。</p>\n<p>管理不同版本的 nodejs 功能可以参考 env 这个子命令: <a href=\"https://pnpm.io/cli/env\" target=\"_blank\" rel=\"noopener noreferrer\">pnpm-cli-env</a></p>\n<h3 id=\"使用-rust-写一些模块\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#使用-rust-写一些模块\"><span>使用 rust 写一些模块</span></a></h3>\n<p>具体可以看<a href=\"https://github.com/pnpm/pnpm/discussions/3419\" target=\"_blank\" rel=\"noopener noreferrer\">pnpm discussion</a>讨论的内容，大概就是作者希望给 pnpm 的一些子命令提供一些 rust 的 cli wrapper 来做提升性能使用。</p>\n","tagOpen":"<template>","tagClose":"</template>"},"script":null,"scriptSetup":null,"scripts":[],"styles":[],"customBlocks":[]},"content":"\n> - Fast, disk space efficient package manager\n> - 快，节省磁盘空间，的 package 管理器\n\n相关链接\n\n- [pnpm 中文网](!https://www.pnpm.cn/)\n\n## 高效利用磁盘空间\n\n硬链接(Hard Link)\n\n```\n硬连接指通过索引节点来进行连接。\n在Linux的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。\n在Linux中，多个文件名指向同一索引节点是存在的。一般这种连接就是硬连接。\n硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。\n只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。\n也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。\n```\n\n软连接(Symbolic Link)\n\n```\n另外一种连接称之为符号连接，也叫软连接。\n软链接文件有类似于Windows的快捷方式。\n它实际上是一个特殊的文件。\n在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。\n```\n\n## 支持 monorepo\n\nmonorepo 的宗旨就是用一个 git 仓库来管理多个子项目，所有的子项目都存放在根目录的 packages 目录下，那么一个子项目就代表一个 package。\n\nmonorepo 管理工具 `lerna`\n\n项目参考：`babel`\n\n## 安全\n\n之前在使用 npm/yarn 的时候，由于 node_module 的扁平结构，如果 A 依赖 B， B 依赖 C，那么 A 当中是可以直接使用 C 的，但问题是 A 当中并没有声明 C 这个依赖。\n\n因此会出现这种非法访问的情况。\n\n但 pnpm 自创了一套依赖管理方式，很好地解决了这个问题，保证了安全性。\n\n> [node_modules 结构历史](!./nodeModules.md)\n\n## 不适用的场景\n\n前面有提到关于 pnpm 的主要问题在于 symlink(软链接)在一些场景下会存在兼容的问题，可以参考作者在 nodejs 那边开的一个 [node discussion](https://github.com/nodejs/node/discussions/37509)\n\n在里面作者提到了目前 nodejs 软连接不能适用的一些场景，希望 nodejs 能提供一种 link 方式而不是使用软连接，同时也提到了 pnpm 目前因为软连接而不能使用的场景:\n\n- Electron 应用无法使用 pnpm\n- 部署在 lambda 上的应用无法使用 pnpm\n- 一些 nodejs 基础库不支持 symlink 的情况导致使用 pnpm 无法正常工作，不过这些库在迭代更新之后也会支持这一特性。\n\n## 未来会做的一些事情\n\n### 脱离 Node.js\n\n具体可以参考 [pnpm discussions](https://github.com/pnpm/pnpm/discussions/3434)\n\n安装 pnpm 的， 可以基本上脱离掉 nodejs 这个 runtime 去进行安装使用。\n\n可以通过 pnpm 来使用不同版本的 nodejs 来去做依赖安装，类似于 nvm 提供的功能。\n\n目前该特性其实已经到了 [beta 版本](https://www.npmjs.com/package/@pnpm/beta)，可以参考这个包。\n\n管理不同版本的 nodejs 功能可以参考 env 这个子命令: [pnpm-cli-env](https://pnpm.io/cli/env)\n\n### 使用 rust 写一些模块\n\n具体可以看[pnpm discussion](https://github.com/pnpm/pnpm/discussions/3419)讨论的内容，大概就是作者希望给 pnpm 的一些子命令提供一些 rust 的 cli wrapper 来做提升性能使用。","excerpt":"","includedFiles":[],"tasklistId":0,"title":"","headers":[{"level":2,"title":"高效利用磁盘空间","slug":"高效利用磁盘空间","link":"#高效利用磁盘空间","children":[]},{"level":2,"title":"支持 monorepo","slug":"支持-monorepo","link":"#支持-monorepo","children":[]},{"level":2,"title":"安全","slug":"安全","link":"#安全","children":[]},{"level":2,"title":"不适用的场景","slug":"不适用的场景","link":"#不适用的场景","children":[]},{"level":2,"title":"未来会做的一些事情","slug":"未来会做的一些事情","link":"#未来会做的一些事情","children":[{"level":3,"title":"脱离 Node.js","slug":"脱离-node-js","link":"#脱离-node-js","children":[]},{"level":3,"title":"使用 rust 写一些模块","slug":"使用-rust-写一些模块","link":"#使用-rust-写一些模块","children":[]}]}],"links":[{"raw":"!https://www.pnpm.cn/","absolute":"/blog/notes/2.nodejs/2.%E5%8C%85%E7%AE%A1%E7%90%86/!https:/www.pnpm.cn/","relative":"notes/2.nodejs/2.%E5%8C%85%E7%AE%A1%E7%90%86/!https:/www.pnpm.cn/"},{"raw":"!./nodeModules.md","absolute":"/blog/notes/2.nodejs/2.%E5%8C%85%E7%AE%A1%E7%90%86/!./nodeModules.md","relative":"notes/2.nodejs/2.%E5%8C%85%E7%AE%A1%E7%90%86/!./nodeModules.md"}]}}
