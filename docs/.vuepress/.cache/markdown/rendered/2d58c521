{"content":"<h2 id=\"第一阶段-npm-3-之前版本\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#第一阶段-npm-3-之前版本\"><span>第一阶段：npm@3 之前版本</span></a></h2>\n<ul>\n<li>依赖树层级太深，会导致 Windows 上的目录路径过长问题</li>\n<li>相同包在不同的依赖项中需要时，会存在多个相同副本</li>\n</ul>\n<div class=\"language- line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"\" style=\"--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212\"><pre class=\"shiki shiki-themes vitesse-light vitesse-dark vp-code\" v-pre=\"\"><code class=\"language-\"><span class=\"line\"><span>node_modules</span></span>\n<span class=\"line\"><span>└─ foo</span></span>\n<span class=\"line\"><span>   ├─ index.js</span></span>\n<span class=\"line\"><span>   ├─ package.json</span></span>\n<span class=\"line\"><span>   └─ node_modules</span></span>\n<span class=\"line\"><span>      └─ bar</span></span>\n<span class=\"line\"><span>         ├─ index.js</span></span>\n<span class=\"line\"><span>         └─ package.json</span></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2 id=\"第二阶段-npm-3-版本-扁平化处理\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#第二阶段-npm-3-版本-扁平化处理\"><span>第二阶段：npm@3 版本，扁平化处理</span></a></h2>\n<p>所有的依赖都被拍平到 node_modules 目录下，不再有很深层次的嵌套关系。</p>\n<p>这样在安装新的包时，根据 node require 机制，会不停往上级的 node_modules 当中去找，如果找到相同版本的包就不会重新安装，解决了大量包重复安装的问题，而且依赖层级也不会太深。</p>\n<div class=\"language- line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"\" style=\"--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212\"><pre class=\"shiki shiki-themes vitesse-light vitesse-dark vp-code\" v-pre=\"\"><code class=\"language-\"><span class=\"line\"><span>node_modules</span></span>\n<span class=\"line\"><span>├─ foo</span></span>\n<span class=\"line\"><span>|  ├─ index.js</span></span>\n<span class=\"line\"><span>|  └─ package.json</span></span>\n<span class=\"line\"><span>└─ bar</span></span>\n<span class=\"line\"><span>   ├─ index.js</span></span>\n<span class=\"line\"><span>   └─ package.json</span></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>但还是存在一些问题</p>\n<ul>\n<li>依赖结构的不确定性。</li>\n<li>扁平化算法本身的复杂性很高，耗时较长。</li>\n<li>项目中仍然可以非法访问没有声明过依赖的包</li>\n<li>这就是为什么会产生依赖结构的不确定问题，也是 lock 文件诞生的原因，无论是 package-lock.json(npm 5.x 才出现)还是 yarn.lock，都是为了保证 install 之后都产生确定的 node_modules 结构。</li>\n</ul>\n<p>尽管如此，npm/yarn 本身还是存在扁平化算法复杂和 package 非法访问的问题，影响性能和安全</p>\n<h2 id=\"第三阶段-pnpm\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#第三阶段-pnpm\"><span>第三阶段：pnpm</span></a></h2>\n<p>由于扁平化算法的极其复杂，以及会存在多项目间相同依赖副本的情况。pnpm 在尝试解决这些问题时，放弃了扁平化处理 node_modules 的方式。而是采用 硬链+软链 方式。</p>\n<p>这种布局结构的一大好处是只有真正在依赖项中（package.json dependences）的包才能访问</p>\n<div class=\"language- line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"\" style=\"--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212\"><pre class=\"shiki shiki-themes vitesse-light vitesse-dark vp-code\" v-pre=\"\"><code class=\"language-\"><span class=\"line\"><span>node_modules</span></span>\n<span class=\"line\"><span>├─ .pnpm</span></span>\n<span class=\"line\"><span>|  ├─ foo@1.0.0/node_modules/foo</span></span>\n<span class=\"line\"><span>|  |  └─ index.js</span></span>\n<span class=\"line\"><span>|  └─ bar@2.0.0/node_modules/bar</span></span>\n<span class=\"line\"><span>├─ foo -> .pnpm/foo@1.0.0/node_modules/foo</span></span>\n<span class=\"line\"><span>└─ bar -> .pnpm/bar@2.0.0/node_modules/bar</span></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3 id=\"举个例子\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#举个例子\"><span>举个例子</span></a></h3>\n<p>安装一个 express 依赖，会在 node_modules 中形成这样两个目录结构:</p>\n<div class=\"language- line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"\" style=\"--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212\"><pre class=\"shiki shiki-themes vitesse-light vitesse-dark vp-code\" v-pre=\"\"><code class=\"language-\"><span class=\"line\"><span>node_modules/express/...</span></span>\n<span class=\"line\"><span>node_modules/.pnpm/express@4.17.1/node_modules/xxx</span></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>其中第一个路径是 nodejs 正常寻找路径会去找的一个目录，如果去查看这个目录下的内容，会发现里面连个 node_modules 文件都没有：</p>\n<div class=\"language- line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"\" style=\"--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212\"><pre class=\"shiki shiki-themes vitesse-light vitesse-dark vp-code\" v-pre=\"\"><code class=\"language-\"><span class=\"line\"><span>▾ express</span></span>\n<span class=\"line\"><span>    ▸ lib</span></span>\n<span class=\"line\"><span>      History.md</span></span>\n<span class=\"line\"><span>      index.js</span></span>\n<span class=\"line\"><span>      LICENSE</span></span>\n<span class=\"line\"><span>      package.json</span></span>\n<span class=\"line\"><span>      Readme.md</span></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>实际上这个文件只是个软连接，它会形成一个到第二个目录的一个软连接(类似于软件的快捷方式)，这样 node 在找路径的时候，最终会找到 .pnpm 这个目录下的内容。</p>\n<p>其中这个 .pnpm 是个虚拟磁盘目录，然后 express 这个依赖的一些依赖会被平铺到 .pnpm/express@4.17.1/node_modules/ 这个目录下面，这样保证了依赖能够 require 到，同时也不会形成很深的依赖层级。</p>\n<p>在保证了 nodejs 能找到依赖路径的基础上，同时也很大程度上保证了依赖能很好的被放在一起。</p>\n","env":{"base":"/blog/","filePath":"/Users/wangzhijie/Desktop/myspace/wangzhije.github.io/docs/notes/2.nodejs/2.包管理/2.nodeModules.md","filePathRelative":"notes/2.nodejs/2.包管理/2.nodeModules.md","frontmatter":{"title":"node_modules 结构演变","createTime":"2025/08/14 23:23:11","permalink":"/nodejs/package/iv4o5vyi/"},"sfcBlocks":{"template":{"type":"template","content":"<template><h2 id=\"第一阶段-npm-3-之前版本\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#第一阶段-npm-3-之前版本\"><span>第一阶段：npm@3 之前版本</span></a></h2>\n<ul>\n<li>依赖树层级太深，会导致 Windows 上的目录路径过长问题</li>\n<li>相同包在不同的依赖项中需要时，会存在多个相同副本</li>\n</ul>\n<div class=\"language- line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"\" style=\"--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212\"><pre class=\"shiki shiki-themes vitesse-light vitesse-dark vp-code\" v-pre=\"\"><code class=\"language-\"><span class=\"line\"><span>node_modules</span></span>\n<span class=\"line\"><span>└─ foo</span></span>\n<span class=\"line\"><span>   ├─ index.js</span></span>\n<span class=\"line\"><span>   ├─ package.json</span></span>\n<span class=\"line\"><span>   └─ node_modules</span></span>\n<span class=\"line\"><span>      └─ bar</span></span>\n<span class=\"line\"><span>         ├─ index.js</span></span>\n<span class=\"line\"><span>         └─ package.json</span></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2 id=\"第二阶段-npm-3-版本-扁平化处理\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#第二阶段-npm-3-版本-扁平化处理\"><span>第二阶段：npm@3 版本，扁平化处理</span></a></h2>\n<p>所有的依赖都被拍平到 node_modules 目录下，不再有很深层次的嵌套关系。</p>\n<p>这样在安装新的包时，根据 node require 机制，会不停往上级的 node_modules 当中去找，如果找到相同版本的包就不会重新安装，解决了大量包重复安装的问题，而且依赖层级也不会太深。</p>\n<div class=\"language- line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"\" style=\"--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212\"><pre class=\"shiki shiki-themes vitesse-light vitesse-dark vp-code\" v-pre=\"\"><code class=\"language-\"><span class=\"line\"><span>node_modules</span></span>\n<span class=\"line\"><span>├─ foo</span></span>\n<span class=\"line\"><span>|  ├─ index.js</span></span>\n<span class=\"line\"><span>|  └─ package.json</span></span>\n<span class=\"line\"><span>└─ bar</span></span>\n<span class=\"line\"><span>   ├─ index.js</span></span>\n<span class=\"line\"><span>   └─ package.json</span></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>但还是存在一些问题</p>\n<ul>\n<li>依赖结构的不确定性。</li>\n<li>扁平化算法本身的复杂性很高，耗时较长。</li>\n<li>项目中仍然可以非法访问没有声明过依赖的包</li>\n<li>这就是为什么会产生依赖结构的不确定问题，也是 lock 文件诞生的原因，无论是 package-lock.json(npm 5.x 才出现)还是 yarn.lock，都是为了保证 install 之后都产生确定的 node_modules 结构。</li>\n</ul>\n<p>尽管如此，npm/yarn 本身还是存在扁平化算法复杂和 package 非法访问的问题，影响性能和安全</p>\n<h2 id=\"第三阶段-pnpm\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#第三阶段-pnpm\"><span>第三阶段：pnpm</span></a></h2>\n<p>由于扁平化算法的极其复杂，以及会存在多项目间相同依赖副本的情况。pnpm 在尝试解决这些问题时，放弃了扁平化处理 node_modules 的方式。而是采用 硬链+软链 方式。</p>\n<p>这种布局结构的一大好处是只有真正在依赖项中（package.json dependences）的包才能访问</p>\n<div class=\"language- line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"\" style=\"--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212\"><pre class=\"shiki shiki-themes vitesse-light vitesse-dark vp-code\" v-pre=\"\"><code class=\"language-\"><span class=\"line\"><span>node_modules</span></span>\n<span class=\"line\"><span>├─ .pnpm</span></span>\n<span class=\"line\"><span>|  ├─ foo@1.0.0/node_modules/foo</span></span>\n<span class=\"line\"><span>|  |  └─ index.js</span></span>\n<span class=\"line\"><span>|  └─ bar@2.0.0/node_modules/bar</span></span>\n<span class=\"line\"><span>├─ foo -> .pnpm/foo@1.0.0/node_modules/foo</span></span>\n<span class=\"line\"><span>└─ bar -> .pnpm/bar@2.0.0/node_modules/bar</span></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3 id=\"举个例子\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#举个例子\"><span>举个例子</span></a></h3>\n<p>安装一个 express 依赖，会在 node_modules 中形成这样两个目录结构:</p>\n<div class=\"language- line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"\" style=\"--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212\"><pre class=\"shiki shiki-themes vitesse-light vitesse-dark vp-code\" v-pre=\"\"><code class=\"language-\"><span class=\"line\"><span>node_modules/express/...</span></span>\n<span class=\"line\"><span>node_modules/.pnpm/express@4.17.1/node_modules/xxx</span></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>其中第一个路径是 nodejs 正常寻找路径会去找的一个目录，如果去查看这个目录下的内容，会发现里面连个 node_modules 文件都没有：</p>\n<div class=\"language- line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"\" style=\"--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212\"><pre class=\"shiki shiki-themes vitesse-light vitesse-dark vp-code\" v-pre=\"\"><code class=\"language-\"><span class=\"line\"><span>▾ express</span></span>\n<span class=\"line\"><span>    ▸ lib</span></span>\n<span class=\"line\"><span>      History.md</span></span>\n<span class=\"line\"><span>      index.js</span></span>\n<span class=\"line\"><span>      LICENSE</span></span>\n<span class=\"line\"><span>      package.json</span></span>\n<span class=\"line\"><span>      Readme.md</span></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>实际上这个文件只是个软连接，它会形成一个到第二个目录的一个软连接(类似于软件的快捷方式)，这样 node 在找路径的时候，最终会找到 .pnpm 这个目录下的内容。</p>\n<p>其中这个 .pnpm 是个虚拟磁盘目录，然后 express 这个依赖的一些依赖会被平铺到 .pnpm/express@4.17.1/node_modules/ 这个目录下面，这样保证了依赖能够 require 到，同时也不会形成很深的依赖层级。</p>\n<p>在保证了 nodejs 能找到依赖路径的基础上，同时也很大程度上保证了依赖能很好的被放在一起。</p>\n</template>","contentStripped":"<h2 id=\"第一阶段-npm-3-之前版本\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#第一阶段-npm-3-之前版本\"><span>第一阶段：npm@3 之前版本</span></a></h2>\n<ul>\n<li>依赖树层级太深，会导致 Windows 上的目录路径过长问题</li>\n<li>相同包在不同的依赖项中需要时，会存在多个相同副本</li>\n</ul>\n<div class=\"language- line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"\" style=\"--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212\"><pre class=\"shiki shiki-themes vitesse-light vitesse-dark vp-code\" v-pre=\"\"><code class=\"language-\"><span class=\"line\"><span>node_modules</span></span>\n<span class=\"line\"><span>└─ foo</span></span>\n<span class=\"line\"><span>   ├─ index.js</span></span>\n<span class=\"line\"><span>   ├─ package.json</span></span>\n<span class=\"line\"><span>   └─ node_modules</span></span>\n<span class=\"line\"><span>      └─ bar</span></span>\n<span class=\"line\"><span>         ├─ index.js</span></span>\n<span class=\"line\"><span>         └─ package.json</span></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h2 id=\"第二阶段-npm-3-版本-扁平化处理\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#第二阶段-npm-3-版本-扁平化处理\"><span>第二阶段：npm@3 版本，扁平化处理</span></a></h2>\n<p>所有的依赖都被拍平到 node_modules 目录下，不再有很深层次的嵌套关系。</p>\n<p>这样在安装新的包时，根据 node require 机制，会不停往上级的 node_modules 当中去找，如果找到相同版本的包就不会重新安装，解决了大量包重复安装的问题，而且依赖层级也不会太深。</p>\n<div class=\"language- line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"\" style=\"--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212\"><pre class=\"shiki shiki-themes vitesse-light vitesse-dark vp-code\" v-pre=\"\"><code class=\"language-\"><span class=\"line\"><span>node_modules</span></span>\n<span class=\"line\"><span>├─ foo</span></span>\n<span class=\"line\"><span>|  ├─ index.js</span></span>\n<span class=\"line\"><span>|  └─ package.json</span></span>\n<span class=\"line\"><span>└─ bar</span></span>\n<span class=\"line\"><span>   ├─ index.js</span></span>\n<span class=\"line\"><span>   └─ package.json</span></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>但还是存在一些问题</p>\n<ul>\n<li>依赖结构的不确定性。</li>\n<li>扁平化算法本身的复杂性很高，耗时较长。</li>\n<li>项目中仍然可以非法访问没有声明过依赖的包</li>\n<li>这就是为什么会产生依赖结构的不确定问题，也是 lock 文件诞生的原因，无论是 package-lock.json(npm 5.x 才出现)还是 yarn.lock，都是为了保证 install 之后都产生确定的 node_modules 结构。</li>\n</ul>\n<p>尽管如此，npm/yarn 本身还是存在扁平化算法复杂和 package 非法访问的问题，影响性能和安全</p>\n<h2 id=\"第三阶段-pnpm\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#第三阶段-pnpm\"><span>第三阶段：pnpm</span></a></h2>\n<p>由于扁平化算法的极其复杂，以及会存在多项目间相同依赖副本的情况。pnpm 在尝试解决这些问题时，放弃了扁平化处理 node_modules 的方式。而是采用 硬链+软链 方式。</p>\n<p>这种布局结构的一大好处是只有真正在依赖项中（package.json dependences）的包才能访问</p>\n<div class=\"language- line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"\" style=\"--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212\"><pre class=\"shiki shiki-themes vitesse-light vitesse-dark vp-code\" v-pre=\"\"><code class=\"language-\"><span class=\"line\"><span>node_modules</span></span>\n<span class=\"line\"><span>├─ .pnpm</span></span>\n<span class=\"line\"><span>|  ├─ foo@1.0.0/node_modules/foo</span></span>\n<span class=\"line\"><span>|  |  └─ index.js</span></span>\n<span class=\"line\"><span>|  └─ bar@2.0.0/node_modules/bar</span></span>\n<span class=\"line\"><span>├─ foo -> .pnpm/foo@1.0.0/node_modules/foo</span></span>\n<span class=\"line\"><span>└─ bar -> .pnpm/bar@2.0.0/node_modules/bar</span></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><h3 id=\"举个例子\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#举个例子\"><span>举个例子</span></a></h3>\n<p>安装一个 express 依赖，会在 node_modules 中形成这样两个目录结构:</p>\n<div class=\"language- line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"\" style=\"--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212\"><pre class=\"shiki shiki-themes vitesse-light vitesse-dark vp-code\" v-pre=\"\"><code class=\"language-\"><span class=\"line\"><span>node_modules/express/...</span></span>\n<span class=\"line\"><span>node_modules/.pnpm/express@4.17.1/node_modules/xxx</span></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>其中第一个路径是 nodejs 正常寻找路径会去找的一个目录，如果去查看这个目录下的内容，会发现里面连个 node_modules 文件都没有：</p>\n<div class=\"language- line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"\" style=\"--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212\"><pre class=\"shiki shiki-themes vitesse-light vitesse-dark vp-code\" v-pre=\"\"><code class=\"language-\"><span class=\"line\"><span>▾ express</span></span>\n<span class=\"line\"><span>    ▸ lib</span></span>\n<span class=\"line\"><span>      History.md</span></span>\n<span class=\"line\"><span>      index.js</span></span>\n<span class=\"line\"><span>      LICENSE</span></span>\n<span class=\"line\"><span>      package.json</span></span>\n<span class=\"line\"><span>      Readme.md</span></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>实际上这个文件只是个软连接，它会形成一个到第二个目录的一个软连接(类似于软件的快捷方式)，这样 node 在找路径的时候，最终会找到 .pnpm 这个目录下的内容。</p>\n<p>其中这个 .pnpm 是个虚拟磁盘目录，然后 express 这个依赖的一些依赖会被平铺到 .pnpm/express@4.17.1/node_modules/ 这个目录下面，这样保证了依赖能够 require 到，同时也不会形成很深的依赖层级。</p>\n<p>在保证了 nodejs 能找到依赖路径的基础上，同时也很大程度上保证了依赖能很好的被放在一起。</p>\n","tagOpen":"<template>","tagClose":"</template>"},"script":null,"scriptSetup":null,"scripts":[],"styles":[],"customBlocks":[]},"content":"\n## 第一阶段：npm@3 之前版本\n\n- 依赖树层级太深，会导致 Windows 上的目录路径过长问题\n- 相同包在不同的依赖项中需要时，会存在多个相同副本\n\n```\nnode_modules\n└─ foo\n   ├─ index.js\n   ├─ package.json\n   └─ node_modules\n      └─ bar\n         ├─ index.js\n         └─ package.json\n```\n\n## 第二阶段：npm@3 版本，扁平化处理\n\n所有的依赖都被拍平到 node_modules 目录下，不再有很深层次的嵌套关系。\n\n这样在安装新的包时，根据 node require 机制，会不停往上级的 node_modules 当中去找，如果找到相同版本的包就不会重新安装，解决了大量包重复安装的问题，而且依赖层级也不会太深。\n\n```\nnode_modules\n├─ foo\n|  ├─ index.js\n|  └─ package.json\n└─ bar\n   ├─ index.js\n   └─ package.json\n```\n\n但还是存在一些问题\n\n- 依赖结构的不确定性。\n- 扁平化算法本身的复杂性很高，耗时较长。\n- 项目中仍然可以非法访问没有声明过依赖的包\n- 这就是为什么会产生依赖结构的不确定问题，也是 lock 文件诞生的原因，无论是 package-lock.json(npm 5.x 才出现)还是 yarn.lock，都是为了保证 install 之后都产生确定的 node_modules 结构。\n\n尽管如此，npm/yarn 本身还是存在扁平化算法复杂和 package 非法访问的问题，影响性能和安全\n\n## 第三阶段：pnpm\n\n由于扁平化算法的极其复杂，以及会存在多项目间相同依赖副本的情况。pnpm 在尝试解决这些问题时，放弃了扁平化处理 node_modules 的方式。而是采用 硬链+软链 方式。\n\n这种布局结构的一大好处是只有真正在依赖项中（package.json dependences）的包才能访问\n\n```\nnode_modules\n├─ .pnpm\n|  ├─ foo@1.0.0/node_modules/foo\n|  |  └─ index.js\n|  └─ bar@2.0.0/node_modules/bar\n├─ foo -> .pnpm/foo@1.0.0/node_modules/foo\n└─ bar -> .pnpm/bar@2.0.0/node_modules/bar\n```\n\n### 举个例子\n\n安装一个 express 依赖，会在 node_modules 中形成这样两个目录结构:\n\n```\nnode_modules/express/...\nnode_modules/.pnpm/express@4.17.1/node_modules/xxx\n```\n\n其中第一个路径是 nodejs 正常寻找路径会去找的一个目录，如果去查看这个目录下的内容，会发现里面连个 node_modules 文件都没有：\n\n```\n▾ express\n    ▸ lib\n      History.md\n      index.js\n      LICENSE\n      package.json\n      Readme.md\n```\n\n实际上这个文件只是个软连接，它会形成一个到第二个目录的一个软连接(类似于软件的快捷方式)，这样 node 在找路径的时候，最终会找到 .pnpm 这个目录下的内容。\n\n其中这个 .pnpm 是个虚拟磁盘目录，然后 express 这个依赖的一些依赖会被平铺到 .pnpm/express@4.17.1/node_modules/ 这个目录下面，这样保证了依赖能够 require 到，同时也不会形成很深的依赖层级。\n\n在保证了 nodejs 能找到依赖路径的基础上，同时也很大程度上保证了依赖能很好的被放在一起。","excerpt":"","includedFiles":[],"tasklistId":0,"title":"","headers":[{"level":2,"title":"第一阶段：npm@3 之前版本","slug":"第一阶段-npm-3-之前版本","link":"#第一阶段-npm-3-之前版本","children":[]},{"level":2,"title":"第二阶段：npm@3 版本，扁平化处理","slug":"第二阶段-npm-3-版本-扁平化处理","link":"#第二阶段-npm-3-版本-扁平化处理","children":[]},{"level":2,"title":"第三阶段：pnpm","slug":"第三阶段-pnpm","link":"#第三阶段-pnpm","children":[{"level":3,"title":"举个例子","slug":"举个例子","link":"#举个例子","children":[]}]}]}}
