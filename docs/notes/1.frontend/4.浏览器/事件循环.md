---
title: 事件循环
createTime: 2025/08/22 15:28:07
permalink: /frontend/browser/powuicre/
---

## 什么是 Event Loop 事件循环

[whatwg 的 html5规范](https://html.spec.whatwg.org/multipage/webappapis.html#event-loops)

Event-Loop 是一个执行模型，在 html5规范 中进行了浏览器端的 Event-Loop 的明确定义。

> 为了协调事件、用户交互、脚本、渲染、网络等，用户代理（如浏览器）必须使用本节所述的事件循环。
> 
> 每个代理都有一个与之相关联的事件循环，该事件循环对该代理是唯一的。
> 
> 同源窗口代理的事件循环被称为窗口事件循环。
> 
> 专用工作线程代理、共享工作线程代理或服务工作线程代理的事件循环被称为工作线程事件循环。
> 
> 而工作线程代理的事件循环则被称为工作线程事件循环。

## 宏任务和微任务

JS的本质是单线程：

1. 非阻塞性的任务采取同步的方式，直接在主线程的执行栈完成。
2. 阻塞性的任务都会采用异步来执行，异步的工作一般会交给其他线程完成，然后回调函数会放到事件队列中。

javascript 有两种异步任务
- 宏任务 `macro task` 也叫 `tasks`
- 微任务 `micro task` 也叫 `jobs`

### 宏任务

回调会依次进入宏任务队列（macro task queue）的异步任务，等待后续被调用。
包括：
- setTimeout
- setInterval
- I/O
- UI rendering
- requestAnimationFrame (浏览器独有)
- setImmediate (Node独有)

### 微任务

回调会依次进入微任务队列（macro task queue）的异步任务，等待后续被调用。
包括：
- Promise
- Object.observe
- MutationObserver
- process.nextTick(Node独有)

## 宏任务和微任务的执行过程

1. 执行全局 script 代码，这些代码有一些是同步语句，有一些是异步语句（如： setTimeout）；
2. 全局script同步代码执行完毕后，调用栈Stack会清空；
3. 从微任务micro task queue 中取出位于队首的任务，放入调用栈Stack中执行，执行完后micro task queue长度减一；
4. 继续取出微任务micro task queue位于队首的任务，放入调用栈Stack中执行， 以此类推，直到把micro task queue中的所有任务都执行完毕。注意，如果在执行micro task的过程中，产生了micro task那么会加入到队列的末尾，也会在这个周期被调用执行；
5. micro task中的所有无人都执行完毕，此时 micro task queue 为空队列，调用栈Stack也为空；
6. 取出宏队列 macro task queue 中位于队首的任务，放入Stack中执行；
7. 执行完毕后，调用栈Stack为空；
8. 重复第3-7个步骤；
9. 以此继续循环重复；

### 注意

- 宏任务marco task 一次只从队列中取出一个任务执行，执行后就去执行微任务队列中的任务；
- 微任务队列中所有的任务都会依次取出来执行，直到micro task queue为空， 且当前微任务执行过程中产生新的micro task，也会加入到当前micro task queue;
- UI Rendering由浏览器自定判断决定执行节点。但是只要执行UI Rendering，它的节点是在执行完所有 micro task之后，下一个macro task之前，紧跟着执行UI Rendering

## 代码执行

:::code-tabs
@tab javascript
```
console.log('script')

setTimeout(() => {
  console.log('timeout 1')
  Promise.resolve().then(() => {
    console.log('promise 1')
  })
})

new Promise((resolve) => {
  console.log('promise resolver')

  Promise.resolve().then(() => {
    console.log('promise 3')
  })

  resolve('promise 2')
}).then((data) => {
  console.log('promise-then', data)
})

setTimeout(() => {
  console.log('timeout 2')
})

console.log('end')
```
@tab console.log
```
script
promise resolver
end
promise 3
promise-then
promise 2
timeout 1
promise 1
timeout 2
```
:::