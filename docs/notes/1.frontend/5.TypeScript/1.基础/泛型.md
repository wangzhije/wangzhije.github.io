---
title: 泛型
createTime: 2025/08/19 13:52:18
permalink: /frontend/3ltymsh1/
---
## 从问题出发，引出泛型
```typescript
// 打印参数，可以接受任意类型的参数
function echoArg1(arg: any): any {
  console.log('arg', arg)
  return arg;
}
// 问题：虽然都是 any 类型，传入的类型与返回的类型应该是相同的，无法保证
// 引出泛型：入参的类型和返回值类型保持一致
function echoArg2<T>(arg: T): T {
    return arg;
}
// 明确泛型类型
let consoleLog = echoArg2<string>("myString");
// 类型推断
let consoleLog2 = echoArg2("myString")
```

## 动态类型
```typescript
// 数字集合
function addNum(x: number, y: number): Array<number> {
  return [x, y];
}
// 字符串集合
function addStr(x: string, y: string): Array<string> {
    return [x, y]
}
// 泛型：动态类型
function addFn<T>(x: T, y: T): Array<T>{
    return [x, y]
}
// 动态类型，传入类型参数
addFn<number>(1, 2)
addFn<string>('hello', 'world')
addFn(2, 3) // 类型推断
```

## 泛型类型
```typescript
// 泛型函数
function identity<T>(arg: T): T {
    return arg;
}
let myIdentity: <T>(arg: T) => T = identity;

// 不同的泛型参数名称
function identity<U>(arg: U): U {
    return arg;
}
let myIdentity: <U>(arg: U) => U = identity;
```

## 泛型接口
```typescript
// 对象字面量来定义泛型函
function identity<T>(arg: T): T {
    return arg;
}
let myIdentity: {<T>(arg: T): T} = identity;

// 泛型接口
interface GenericIdentityFn {
    <T>(arg: T): T;
}
function identity<T>(arg: T): T {
    return arg;
}
let myIdentity: GenericIdentityFn = identity;
// 把泛型参数当作整个接口的一个参数
// 能清楚的知道使用的具体是哪个泛型类型
let myIdentity: GenericIdentityFn<number> = identity;
```

```typescript
// 不同的泛型参数
function Sub<T, U>(a: T, b: U): Array<T | U> {
  const params: Array<T | U> = [a, b];
  return params;
}

Sub<Boolean, number>(false, 1);
```

## 泛型约束
### extends
```typescript
// 传入的类型可能无对象的属性和方法
function getLegnth<T>(arg:T) {
  return arg.length
}
// 泛型约束
interface Lengthwise {
  length: number;
}
function loggingIdentity<T extends Lengthwise>(arg: T): T {
  console.log(arg.length);  // Now we know it has a .length property, so no more error
  return arg;
}
```

```typescript
// 泛型约束中使用类型参数
function getProperty(obj: T, key: K) {
    return obj[key];
}
let x = { a: 1, b: 2, c: 3, d: 4 };

getProperty(x, "a"); // okay
getProperty(x, "m"); // error，x 中无 key='m'
```

### keyof
```typescript
let user = {
  name: "liushishi",
  age: 18,
};
type UserObj = typeof user; // UserObj 为 { name: string, age: number}
type ObjKey = keyof typeof user; // ObjKey 为 "name" | "age"

function getObjVal<T extends UserObj, K extends ObjKey>(obj: T, key: K): any {
    return obj[key]
}
```



