var v=Object.defineProperty;var u=(m,t,r)=>t in m?v(m,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):m[t]=r;var y=(m,t,r)=>(u(m,typeof t!="symbol"?t+"":t,r),r);class T{constructor(t,r,o){y(this,"x");y(this,"y");y(this,"size");y(this,"typeCount",6);y(this,"matrix",[]);y(this,"data",[]);y(this,"isHandle",!1);y(this,"isSelect",!1);y(this,"score",0);y(this,"target1",{active:!1});y(this,"target2",{});this.x=t,this.y=r,this.size=o,this.getMatrix(),this.init(!0)}click(t){if(this.isHandle)return;const{isSelect:r}=this;if(!r)t.active=!0,this.target1=t,this.isSelect=!0;else{if(this.target1===t)return;this.target1.active=!1,["left","top","bottom","right"].some(o=>this.target1[o]==t)?(this.target2=t,(async()=>(await this.swap(),await this.gameLoop()||await this.swap()))(),this.isSelect=!1):(t.active=!0,this.target1=t,this.isSelect=!0)}}swap(){return new Promise((t,r)=>{const{target1:o,target2:a,data:n}=this,{positionLeft:f,positionTop:s,x:h,y:e}=o,{positionLeft:i,positionTop:p,x:d,y:x}=a;setTimeout(()=>{o.positionLeft=i,o.positionTop=p,o.x=d,o.y=x,a.positionLeft=f,a.positionTop=s,a.x=h,a.y=e,n.forEach(l=>{l.left=n.find(c=>c.x==l.x-1&&c.y==l.y),l.right=n.find(c=>c.x==l.x+1&&c.y==l.y),l.top=n.find(c=>c.x==l.x&&c.y==l.y-1),l.bottom=n.find(c=>c.x==l.x&&c.y==l.y+1)})},0),setTimeout(()=>{t(!0)},500)})}async gameLoop(t=!1){t&&(this.score=0),this.isHandle=!0,await this.remove();let r=this.data.some(o=>o.status==="remove");for(;this.data.some(o=>o.status==="remove");)await this.down(),await this.add(),await this.remove();return this.isHandle=!1,r}remove(){return new Promise((t,r)=>{const{data:o}=this;o.forEach(a=>{const{left:n,right:f,top:s,bottom:h,type:e}=a;(n==null?void 0:n.type)==e&&(f==null?void 0:f.type)==e&&(n.status="remove",a.status="remove",f.status="remove"),(s==null?void 0:s.type)==e&&(h==null?void 0:h.type)==e&&(s.status="remove",a.status="remove",h.status="remove")}),setTimeout(()=>{o.forEach((a,n)=>{a.status==="remove"&&(a.scale=0,this.score+=1)})},100),setTimeout(()=>{t(!0)},500)})}down(){return new Promise((t,r)=>{const{data:o,size:a,x:n,y:f}=this;o.forEach((s,h)=>{let e=0;if(s.status==="remove"){let i=s.top;for(;i;)i.status!=="remove"&&(e+=1),i=i.top;e&&(s.y-=e,s.positionTop=s.positionTop-a*e)}else{let i=s.bottom;for(;i;)i.status==="remove"&&(e+=1),i=i.bottom;e&&(s.y+=e,s.positionTop=s.positionTop+a*e)}}),setTimeout(()=>{t(!0)},500)})}add(){return new Promise((t,r)=>{const{size:o,matrix:a}=this;this.getMatrix(),this.matrix=a.map((n,f)=>n.map((s,h)=>this.data.find(e=>h==e.x&&f==e.y))),this.init(),setTimeout(()=>{this.data.forEach(n=>{n.status==="add"&&(n.scale=1,n.status="normal")})},100),setTimeout(()=>{t(!0)},500)})}getMatrix(){const{x:t,y:r}=this,o=new Array(t).fill(void 0),a=new Array(r).fill(void 0).map(n=>o);this.matrix=a}init(t=!1){const{x:r,y:o,typeCount:a,matrix:n,size:f}=this,s=[];let h=0,e=0;for(let i=0,p=Math.pow(r,2);i<p;i++){let d;try{d=n[e][h]}catch{}let x=d&&d.status!=="remove",l={type:x?d.type:Math.floor(Math.random()*a),x:h,y:e,status:t||x?"normal":"add",positionLeft:x?d.positionLeft:f*h,positionTop:x?d.positionTop:f*e,left:void 0,top:void 0,bottom:void 0,right:void 0,scale:t||x?1:0,key:d?d.key+i:`${h}${e}`,active:!1};s.push(l),h++,h==r&&(h=0,e++)}s.forEach(i=>{i.left=s.find(p=>p.x==i.x-1&&p.y==i.y),i.right=s.find(p=>p.x==i.x+1&&p.y==i.y),i.top=s.find(p=>p.x==i.x&&p.y==i.y-1),i.bottom=s.find(p=>p.x==i.x&&p.y==i.y+1)}),this.data=s}}export{T as S};
